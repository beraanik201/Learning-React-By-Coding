Q1. Write Hello World using Javascript.
=> <!DOCTYPE html>
<html>
  <head>
    <title>Hello World using Javascript</title>
  </head>
  <body>
      <div id="root"></div>
      
      <script>
        const heading = document.createElement('h1');
        heading.innerHTML = "Hello World";
        
        const root = document.getElementById('root');
        root.appendChild(heading);
      </script>
  </body>
</html>


2. What is cdn?
=> A Content Delivery Network (CDN) is a globally distributed network of servers that speeds up the delivery of web content by caching it closer to users. We use CDNs to improve website performance, reduce latency, and handle high traffic loads, ensuring a faster and more reliable online experience for users worldwide 

3. What is crossorigin?
=> Cross-Origin Resource Sharing (CORS) is a security mechanism implemented by web browsers that controls how web pages can request resources from a different origin (domain, protocol, or port) than the one from which the page itself was loaded.

4. What is core react fundamental code?
=> //If we have to do multiple nesting for creating element structures, it is is difficult to maintain,
// That is why we use jsx for craeting tags
//But this is core-react


const parent = React.createElement("div", {id: "parent"},
    React.createElement("div", {id: "child"}, [
    React.createElement("h1", {}, "Hello World from Child"),
    React.createElement("h2", {}, "Hello World from Child")
    ]));

    console.log(parent);

// const heading = React.createElement("h1", { id: "heading" }, "Hello World");

const root = ReactDOM.createRoot(document.getElementById("root"));
console.log(root);

root.render(parent);

**This React.createElement() is Object.
  when we render this element into DOM, it converts to HTML and browser understands it.



5.why is react called a library and not a framework?
=> React's core responsibility is limited to the "view" layer of an application, specifically building user interfaces. 
we can inject react into specific sections also like header, footer any specific part of a website.


6. ***ReactElement is an object. => converts to HTML and browser understands it.

7. What is package.json?
=> package.json is a file that is automatically created when we create a project 
   using npm init command.
   package.json is a configuration of npm.

8. What is a bundler? (like webpack, parcel, vite)
=> A bundler is a tool that takes multiple files and combines them into a single file.
   Bundler bundles our files so that it can ship to production.

9. What is parcel?
=> Parcel is a web application bundler, similar to tools like Webpack and Rollup.
   It takes in various assets like JavaScript, CSS, HTML, and images, and processes them to create optimized bundles for deployment.

   In our vs code we run - npm install -D parcel  --> D for Dev dependency
   In package.json we can see parcel is added in dev dependency.

10. what is difference between (~2.8.3) and (^2.8.3) in package.json?
=> ~2.8.3 means it will update you to all future patch versions, but will not update you to the next minor version.
   ^2.8.3 means it will update you to all future minor/patch versions, but will not update you to the next major version.

11. What is the difference between a package.json and a package-lock.json?
=> package.json is a file that is automatically created when we create a project 
   using npm init command.
   package.json is a configuration of npm.

   package-lock.json is automatically generated for any operations where npm modifies either the node_modules tree, or package.json.
   It describes the exact tree that was generated, such that subsequent installs are able to generate identical trees, regardless of intermediate dependency updates.
   It is intended to be committed into source repositories, and serves various purposes:
     i. Describe a single representation of a dependency tree such that teammates, deployments, and continuous integration are guaranteed to install exactly the same dependencies.
    ii. Provide a facility for users to "time-travel" to previous states of node_modules without having to commit the entire directory tree.
   iii. To facilitate greater visibility of tree changes through readable diffs.


12. What is the difference between a dependency and a devDependency?
=> Dependencies are the libraries or packages that your project needs to run in a production environment.

   DevDependencies are the libraries or packages that are only needed during the development phase of project.
   These packages are not required for the application to run in a production environment.

13. What is .gitignore file? Why it is needed?
=> .gitignore is a text file that tells Git which files or directories to ignore in a project.
    It is needed to avoid committing unnecessary files, such as build artifacts, temporary files, or sensitive information, to the repository.

14. How to start a project using parcel?
=> For this project - npx parcel index.html
   npx is a package runner tool that comes with npm 5.2+ and higher.
   It is used to execute packages directly from the npm registry without having to install them globally on your system.


15. How to install react and react-dom?
=> npm install react
   npm install react-dom

16. "Browser scripts cannot have import or export." - solve it by adding type="module" in script tag in index.html
   <script type="module" src="./App.js"></script>

17. Parcel - behind the scenes
=> -Devbuild - Transpiler (babel) - converts jsx to js
   -Local server - (localhost:1234)
   -Bundler - bundles our files so that it can ship to production
   -HMR - Hot Module Replacement - reloads the page when we save the file
   -File watcher - watches for file changes (written in c++)
   -caching - Faster builds
   -Image optimization - compresses the images
   -Minification - removes unnecessary spaces, comments, etc
   -Tree shaking - removes unused code
   -consistent hashing - for long term caching
   -code splitting - splits the code into smaller chunks
   -production build - creates a production build of the app
   -Diagonostic - shows errors and warnings in the console
   -HTTPS - serves the app over HTTPS
   -Differential Bundling - creates different bundles for different browsers

18. What is Dist folder?
=> The dist folder, short for "distribution," is a directory commonly used in software development to store the final, production-ready version of a project or application.
   It typically contains optimized and minified files that are ready to be deployed to a web server or distributed to users.

19. How to know how to start a react project?
=> We can check in package.json file for the scripts section.
   e.g.-"scripts": {
         "start": "parcel index.html",
         "build": "parcel build index.html",
         "test": "jest"
         },
   Here we can see to start the project we have to run - npm run start / npm start
                                                         npm run build (for production build)

20. What is jsx?
=> JSX stands for JavaScript XML.
   Note: JSX is not a separate programming language, but rather a syntax extension for JavaScript.
         It is not part of React itself, but is commonly used with React to describe the UI structure.
         JSX is not Html inside JS. It is a syntax extension that looks similar to HTML.


21. How jsx is converted to js? 
    (e.g. <h1 id="heading">Hello World from jsx</h1>)
=> Behind the scenes, JSX is transformed into regular JavaScript function calls that create React elements.
   The transformation is typically done using a tool like Babel, which is a popular JavaScript transpiler.
   Parcel uses babel to convert jsx to React.createElement.

   JSX ==> React.createElement -JS Object ==> HTMLElement(render)   - Here Babel is converting jsx to React.createElement


23. What is transpiler?
=> A transpiler (short for "source-to-source compiler") is a type of compiler that takes source code 
   written in one programming language and transforms it into equivalent source code in another programming 
   language.
   Transpilers are commonly used to convert code from a newer version of a language to an older version, 
   or to convert code from one language to another that has similar features.



24. ***We have to use camelCase for attributes in jsx instead of lowercase.
     e.g. - class --> className
           tabindex --> tabIndex
           onclick --> onClick
           for --> htmlFor


25. ***If we write jsx in multiple lines, we have to wrap it in brackets.


26. What are components in react?
=> Components are the building blocks of a React application. They are reusable, self-contained pieces of
   code that define how a certain part of the user interface (UI) should look and behave.
   Components can be thought of as custom HTML elements that encapsulate their own structure, 
   styling, and behavior.

   i> Functional Components: These are JavaScript functions that return JSX to define the UI.
                           (A Arrow function that returns a React element) - [We can write normal function also]
                           Example:
                           const MyComponent = () => {
                             return <div>Hello, I am a functional component!</div>;
                           };

                           or if the function has only one return statement, we can write it like this:
                           const MyComponent = () => <div>Hello, I am a functional component!</div>;

                     ***How to render a functional component to the UI?
                       ==> const HeadingComponent = () => <h1>This is a Heading Component</h1>;
                           const root = ReactDOM.createRoot(document.getElementById("root"));
                           root.render(<HeadingComponent/>);  //we have to use the component as a tag


  ii> Class Based Components (older way, less used now)



27. What is component composition?
=> Component composition is a design pattern in React that allows you to build complex UIs by combining
   simpler, reusable components. It involves nesting components within other components to create a hierarchy
   of UI elements.

   Example:
   const Header = () => <header><h1>My Website</h1></header>;
   const Footer = () => <footer><p>© 2023 My Website</p></footer>;
   const MainContent = () => <main><p>Welcome to my website!</p></main>;

   const App = () => (
     <div>
       <Header />
       <MainContent />
       <Footer />
     </div>
   );

   In this example, the App component is composed of three smaller components: Header, MainContent, and Footer.
   Each of these components is responsible for rendering a specific part of the UI, and they are combined
   together in the App component to create the overall structure of the application.


28. Give example where we can inject React element in React element?
=> const elem = <span>Namaste React</span>;
   const title = (
      <h1> {elem} using JSX</h1>
   )

   const HeadingComponent = () => (
      <div id="container">
         {title}
      </div>
   )



29. What is the difference between React Element and React Component?
=> React Element: A React element is a plain JavaScript object that represents a DOM node or a component instance.
                  It is the smallest building block of a React application and describes what you want to see on the screen.
                  React elements are created using JSX or the React.createElement() method.

   React Component: A React component is a reusable piece of code that defines how a certain part of the user interface (UI) should look and behave.
                    Components can be thought of as custom HTML elements that encapsulate their own structure, styling, and behavior.
                    Components can be functional components (JavaScript functions that return JSX) or class-based components (ES6 classes that extend React.Component).

   In summary, a React element is an object that represents a DOM node or component instance, while a React component is a reusable 
   piece of code that defines the structure and behavior of a part of the UI.


30. What is Cross Site Scripting (XSS) attack? How jsx prevents it?
=> Cross-Site Scripting (XSS) is a type of security vulnerability that allows attackers to inject malicious 
scripts into web pages viewed by other users.
   JSX prevents XSS attacks by escaping any values embedded in JSX before rendering them to the DOM.
   This means that any potentially dangerous characters (like <, >, &, etc.) are converted to their 
   corresponding HTML entities (like &lt;, &gt;, &amp;, etc.), which prevents them from being interpreted 
   as executable code by the browser.



31. Describe where to use which one? - {Title()} vs <Title /> vs <Title></Title>
=> {Title()} - This syntax is used to call a regular JavaScript function named Title and embed its return value
                directly into JSX. This is typically used when Title is a function that returns a React element or
                some other value that you want to render.

   <Title /> - This syntax is used to render a React component named Title. It is a self-closing tag, which means
                that it does not have any children. This is typically used when Title is a functional or class-based
                component that you want to include in your JSX.

   <Title></Title> - This syntax is also used to render a React component named Title, but it allows you to include
                     children between the opening and closing tags. This is useful when Title is a component that
                     expects to receive child elements as props.

   In summary, use {Title()} to call a regular function and embed its return value, use <Title /> to render a 
   self-contained React component, and use <Title></Title> to render a React component that can accept child elements.


32. how to write inline css in react jsx?
=> In React JSX, we can write inline CSS styles using the style attribute, 
   but instead of a string (like in plain HTML), we pass a JavaScript object.

   Example:
      function App() {
         const boxStyle = {
         backgroundColor: "lightgreen",
   };

      return (
         <div style={boxStyle}>
            <p style={{ fontWeight: "bold" }}>This is styled with inline CSS!</p>
         </div>
      );
   }


33. What is Props?
=> ***Passing a prop to a function is like passing an argument to a function.

   Props (short for "properties") are a way to pass data from a parent component to a child component in React.
   They are read-only and allow components to be dynamic and reusable by accepting different values.

   Example:
   const Greeting = (props) => {
     return (
      <div>
      console.log(props); //props is an object
        <h1>Hello, {props.name}!</h1>;
      </div>
     )
   };

   const App = () => {
     return (
       <div>
         <Greeting name="Alice" /> //Here we are passing name="Alice" as props to Greeting component
         <Greeting name="Bob" />
       </div>
     );
   };

   In this example, the Greeting component accepts a prop called name and uses it to display a personalized greeting.
   The App component renders two instances of the Greeting component with different name props, resulting in
   "Hello, Alice!" and "Hello, Bob!" being displayed.



34. What is destructuring props on the fly?
=> Destructuring props on the fly refers to the practice of extracting specific properties from the props object
   directly within the function parameter list of a functional component in React.
   This allows for cleaner and more concise code by avoiding repetitive references to props.

   Example without destructuring:
   const Greeting = (props) => {
     return <h1>Hello, {props.name}!</h1>;
   };

   Example with destructuring on the fly:
   const Greeting = ({ name }) => {
     return <h1>Hello, {name}!</h1>;
   };

   In this example, instead of accessing the name property via props.name, we destructure it directly in the
   function parameter list by using { name }. This makes the code more readable and reduces redundancy.
   This is not React specific, it is a feature of JavaScript ES6.

   Basically this is same as:
   const Greeting = (props) => {
     const { name } = props; //destructuring
     return <h1>Hello, {name}!</h1>;
   };



35. What is Config Driven UI?
=> Config Driven UI is a design approach where the user interface (UI) of an application is
   dynamically generated based on configuration data rather than being hardcoded in the application's source code.
   This allows for greater flexibility and adaptability, as changes to the UI can be made by simply updating
   the configuration data without needing to modify the underlying code.

   Example:
   const restaurantList = [
     {
       name: "Meghana Foods",
       cuisine: ["Biryani", "North Indian", "Asian"],
       rating: "4.5",
     },
     {
       name: "KFC",
       cuisine: ["Burger", "Fast Food"],
       rating: "4.2",
     },
   ];

   const RestaurantCard = ({ resName, resCuisine }) => {
     return (
       <div className="res-card">
         <h3>{resName}</h3>
         <h4>{resCuisine}</h4>
       </div>
     );
   };

   const App = () => {
     return (
       <div className="body">
         <div className="search">Search</div>
         <div className="res-container">
           {restaurantList.map((restaurant) => (
             <RestaurantCard
               resName={restaurant.name}
               resCuisine={restaurant.cuisine.join(", ")}
             />
           ))}
         </div>
       </div>
     );
   };

   In this example, the restaurantList array serves as the configuration data that drives the UI.
   The App component maps over this array to dynamically generate RestaurantCard components for each restaurant,
   passing the relevant data as props. This way, if we want to add or remove restaurants, we can simply update
   the restaurantList array without changing the App or RestaurantCard components.



36. Take a real world scenario where data is coming through api and render it.
=> const resObj = {
         info: {
            id: "150591",
            name: "Satkar Restaurant",
            cloudinaryImageId: "rvxp5xbniat84r6efku2",
            locality: "Sinchai Colony",
            areaName: "Satkar Chowk",
            costForTwo: "₹250 for two",
            cuisines: ["South Indian", "Indian", "Salads", "Desserts"],
            avgRating: 4.4,
            veg: true,
            parentId: "21553",
            avgRatingString: "4.4",
            totalRatingsString: "3.2K+",
            sla: {
               deliveryTime: 46,
               lastMileTravel: 13.4,
               serviceability: "SERVICEABLE",
               slaString: "45-50 mins",
               lastMileTravelString: "13.4 km",
               iconType: "ICON_TYPE_EMPTY",
            },
            availability: {
               nextCloseTime: "2025-10-05 22:45:00",
               opened: true,
            },
            badges: {
               imageBadges: [
               {
                  imageId: "Rxawards/_CATEGORY-North%20Indian.png",
                  description: "Delivery!",
               },
               {
                  imageId: "Ratnesh_Badges/Rx_Awards_2025/_Milestone%20Restaurants.png",
                  description: "Delivery!",
               },
               ],
            },
            isOpen: true,
            aggregatedDiscountInfoV2: {},
            type: "F",
            badgesV2: {
               entityBadges: {
               imageBased: {
                  badgeObject: [
                     {
                     attributes: {
                        description: "Delivery!",
                        imageId: "Rxawards/_CATEGORY-North%20Indian.png",
                     },
                     },
                     {
                     attributes: {
                        description: "Delivery!",
                        imageId:
                           "Ratnesh_Badges/Rx_Awards_2025/_Milestone%20Restaurants.png",
                     },
                     },
                  ],
               },
               textBased: {},
               textExtendedBadges: {},
               },
            },
            differentiatedUi: {
               displayType: "ADS_UI_DISPLAY_TYPE_ENUM_DEFAULT",
               differentiatedUiMediaDetails: {
               lottie: {},
               video: {},
               },
            },
            reviewsSummary: {},
            displayType: "RESTAURANT_DISPLAY_TYPE_DEFAULT",
            restaurantOfferPresentationInfo: {},
            externalRatings: {
               aggregatedRating: {
               rating: "--",
               },
            },
            ratingsDisplayPreference: "RATINGS_DISPLAY_PREFERENCE_SHOW_SWIGGY",
         },
         analytics: {
            context: "seo-data-4f8d7ad2-0cfd-43a9-8d2a-31f5ac26c87b",
         },
         cta: {
            link: "https://www.swiggy.com/city/chhindwara/satkar-restaurant-sinchai-colony-satkar-chowk-rest150591",
            type: "WEBLINK",
         },
         };

   const RestaurantCard = (props) => {
   const { resData } = props;
   console.log(resData);
   return (
      <div className="res-card">
         <img
         className="res-logo"
         alt="res-logo"
         src="data:image/jpeg;base64,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"
         />
         <h3>{resData.info.name}</h3>
         <h4>{resData.info.cuisines.join(", ")}</h4>
         <h4>{resData.info.avgRating}</h4>
         <h4>{resData.info.costForTwo}</h4>
         <h4>{resData.info.sla.deliveryTime} mins</h4>
      </div>
   );
   };


   const Body = () => {
   return (
      <div className="body">
         <div className="search">Search</div>
         <div className="res-container">
         <RestaurantCard resData={resObj} />
         </div>
      </div>
   );
   };


   The body is rendered further. Here, the data is coming through an API and is stored in the resObj object.
   The RestaurantCard component takes this object as a prop and extracts the necessary information to display.




37. Why to add a unique key prop when we are rendering a list?
=> In React, when rendering a list of elements using the map() function or similar methods, it is important 
   to add a unique key prop to each element in the list. The key prop identify which items in the list have changed, 
   been added, or removed. This allows React to optimize the rendering process by only updating the parts of the DOM 
   that have actually changed, rather than re-rendering the entire list. This leads to better performance and a smoother 
   user experience.
   Index as a key is not recommended in React because the index of an item in the array can change if the array is 
   modified (e.g., items are added, removed, or reordered).

   



38. Whats are Named and Default Exports?
=> In JavaScript, modules can export values in two primary ways: named exports and default exports.

   Named Exports:
   - Named exports allow you to export multiple values from a module. Each value is exported with its own name.
   - When importing named exports, you must use the same name as the exported value and wrap it in curly braces.
   - Example of Named Export:
     // module.js
     export const foo = 'foo';
     export const bar = 'bar';

     // anotherFile.js
     import { foo, bar } from './module';

   Default Exports:
   - A default export allows you to export a single value from a module. This value can be a function, class, object, or any other type.
   - When importing a default export, you can choose any name for the imported value and do not need to use curly braces.
   - Example of Default Export:
     // module.js
     const baz = 'baz';
     export default baz;

     // anotherFile.js
     import myBaz from './module'; // You can name it anything

   You can also combine both named and default exports in a single module:
   // module.js
   export const foo = 'foo';
   export const bar = 'bar';
   const baz = 'baz';
   export default baz;

   // anotherFile.js
   import myBaz, { foo, bar } from './module';



39. What is react hooks?
=> React Hooks - Normal JS utility functions
   React Hooks are special functions that allow you to use state and other React features in functional components. 
   They were introduced in React 16.8 to enable developers to manage state and side effects without needing to convert 
   functional components into class components. Hooks provide a more concise and readable way to handle component logic.

   Some commonly used React Hooks include:
   1. useState: Allows you to add state to functional components.
   2. useEffect: Lets you perform side effects (like data fetching, subscriptions, or manually changing the DOM) in 
      functional components.
   3. useContext: Enables you to access context values without using the Context.Consumer component.
   4. useReducer: Provides an alternative to useState for managing complex state logic.
   5. useRef: Allows you to create mutable references that persist across renders, often used for accessing DOM elements.

   Example of using useState and useEffect hooks:
   import React, { useState, useEffect } from 'react';

   function Counter() {
      const [count, setCount] = useState(0);

      useEffect(() => {
         document.title = `You clicked ${count} times`;
      }, [count]); // Only re-run the effect if count changes

      return (
         <div>
            <p>You clicked {count} times</p>
            <button onClick={() => setCount(count + 1)}>
               Click me
            </button>
         </div>
      );
   }

   In this example, the Counter component uses the useState hook to manage the count state and the useEffect hook 
   to update the document title whenever the count changes.


   ****When a state variable updated React re-renders the respective component.****




40. How React works behind the scenes?
=> React is a JavaScript library for building user interfaces, and it works behind the scenes through a series of steps
   to efficiently update and render components. Here's a simplified overview of how React works:

   1. ****Virtual DOM: React uses a virtual representation of the actual DOM (Document Object Model) called the Virtual DOM. 
      This is a lightweight copy of the real DOM that allows React to make updates more efficiently.

   2. ******Reconciliation (React Fiber): When a component's state or props change, React performs a process called reconciliation. It compares 
      the new Virtual DOM with the previous version to determine what has changed. It is also knows as "Diffing".

      Diff Algorithm:
      - React uses a diffing algorithm to compare the new Virtual DOM with the previous version.
      React Fiber:
      - React Fiber is a new way of finding the differences between the two Virtual DOMs and Updates the DOM.
      - The goal of React Fiber is to enable incremental rendering (The ability to split rendering work into chunks spread it out over multiple frames) of the Virtual DOM.

   3. JSX Syntax: React uses JSX (JavaScript XML) syntax, which allows developers to write HTML-like code within JavaScript. 
      This makes it easier to create and manage UI elements.

   4. State and Props: Components can have state (data that can change over time) and props (data passed from parent 
      components). When the state or props of a component change, React triggers a re-render of that component.

   5. Component Structure: React applications are built using components, which are reusable and self-contained pieces 
      of UI. Each component can have its own state and props (properties).

   6. Efficient Updates: Instead of updating the entire DOM, React calculates the minimum number of changes needed to 
      update the real DOM based on the differences found during reconciliation. This process is known as "diffing."

   7. Batch Updates: React batches multiple updates together to optimize performance. Instead of updating the DOM immediately 
      after each change, it waits until all changes are made before applying them in one go.

   8. Rendering: Once the necessary changes are determined, React updates the real DOM with only the parts that have changed, 
      resulting in a more efficient rendering process.

   9. Event Handling: React provides a synthetic event system that normalizes events across different browsers, making it easier 
      to handle user interactions.

   10. Lifecycle Methods: Class components in React have lifecycle methods (e.g., componentDidMount, componentDidUpdate) that allow 
       developers to hook into specific points in a component's lifecycle for tasks like data fetching or cleanup.




41. Describe monolith ic and microservice architecture.
=> Monolithic Architecture:
   - In a monolithic architecture, the entire application is built as a single, unified unit. All components and functionalities 
     are tightly integrated and run within a single process.
   - Advantages:
     1. Simplicity: Easier to develop, test, and deploy as a single unit.
     2. Performance: Direct communication between components can lead to better performance.
     3. Easier to manage: Fewer moving parts to coordinate.
   - Disadvantages:
     1. Scalability: Difficult to scale individual components; the entire application must be scaled together.
     2. Maintenance: As the application grows, it can become complex and harder to maintain.
     3. Deployment: A small change requires redeploying the entire application.

   Microservices Architecture:
   - In a microservices architecture, the application is divided into smaller, independent services that communicate with each other 
     through APIs. Each service is responsible for a specific functionality and can be developed, deployed, and scaled independently.
   - Advantages:
     1. Scalability: Individual services can be scaled independently based on demand.
     2. Flexibility: Different services can use different technologies and programming languages.
     3. Resilience: Failure in one service does not necessarily affect the entire application.
     4. Faster development: Teams can work on different services simultaneously.
   - Disadvantages:
     1. Complexity: More moving parts to manage, including inter-service communication and data consistency.
     2. Deployment: Requires more sophisticated deployment strategies (e.g., containerization, orchestration).
     3. Monitoring: More challenging to monitor and debug issues across multiple services.



42. What is seperation of concerns?
=> Separation of Concerns (SoC) is a design principle in software engineering that advocates for dividing a software application 
   into distinct sections, each responsible for a specific functionality or concern. The main idea is to separate different aspects of the application 
   to improve maintainability, readability, and scalability.

   In the context of web development and React, Separation of Concerns can be applied in several ways:

   1. Component-Based Architecture: React promotes building applications using reusable components. Each component should have a single responsibility, 
      focusing on a specific part of the UI or functionality. This makes it easier to manage and update individual components without affecting others.

   2. State Management: Separating state management from UI components helps in maintaining a clear distinction between the application's data and its presentation. 
      Libraries like Redux or Context API can be used to manage state separately from the components that render the UI.

   3. Styling: Using CSS-in-JS libraries or CSS modules allows for separating styles from component logic, making it easier to manage and update styles independently.

   4. Business Logic: Keeping business logic separate from UI components ensures that the core functionality of the application is not tightly coupled with its presentation layer. 
      This can be achieved by using services or utility functions to handle business logic.

   5. File Structure: Organizing files and folders based on their purpose (e.g., components, services, utilities) helps in maintaining a clear structure and makes it easier to locate specific parts of the codebase.

   By adhering to the principle of Separation of Concerns, developers can create more modular, maintainable, and scalable applications.



43. What is single responsibility principle?
=> The Single Responsibility Principle (SRP) is one of the five SOLID principles of object-oriented design. It states that a class or 
   module should have only one reason to change, meaning it should have only one responsibility or job.

   In the context of software development, adhering to the Single Responsibility Principle helps in creating more maintainable, understandable, and testable code. 
   When a class or module has a single responsibility, it becomes easier to modify or extend its functionality without affecting other parts of the codebase.

   In React development, the Single Responsibility Principle can be applied by ensuring that each component has a specific purpose and does not handle multiple concerns. 
   For example, a component should focus on rendering UI elements and managing its own state, while business logic and data fetching should be handled by separate services or hooks.

   Benefits of following the Single Responsibility Principle include:
   1. Improved maintainability: Changes to one part of the code are less likely to impact other parts.
   2. Easier testing: Components with a single responsibility are easier to test in isolation.
   3. Enhanced readability: Code is more understandable when each component has a clear purpose.
   4. Better reusability: Components can be reused in different contexts without bringing along unnecessary functionality.

   Overall, the Single Responsibility Principle encourages developers to create modular and focused components, leading to cleaner and more efficient codebases.



44. What is useEffect hook?
=> The useEffect hook is a built-in React hook that allows you to perform side effects in functional components. 
   Side effects are operations that can affect other parts of the application or interact with external systems, 
   such as fetching data from an API, updating the DOM, setting up subscriptions, or managing timers.

   ****useEffect is called after the component has rendered.

   The useEffect hook takes two arguments:
   1. A Arrow function that contains the side effect logic. This function is executed after the component renders.
   2. An optional dependency array that specifies when the effect should be re-run. If any value in the dependency 
      array changes, the effect will be re-executed.

   Basic Syntax:
   import React, { useEffect } from 'react';

   function MyComponent() {
      useEffect(() => {
         // Side effect logic here (e.g., data fetching, subscriptions)
         console.log('Component mounted or updated');

         // Optional cleanup function
         return () => {
            console.log('Component unmounted or before next effect');
         };
      }, []); // Empty dependency array means this effect runs only once on mount

      return <div>My Component</div>;
   }

   Key Points:
   - If you provide an empty dependency array ([]), the effect will run only once when the component mounts and not on subsequent updates.
   - If you provide a dependency array with specific values ([prop1, state1]), the effect will run whenever any of those values change.
   - If you omit the dependency array altogether, the effect will run after every render, which can lead to performance issues if not 
   - managed carefully.
   - The cleanup function (returned from the effect function) is used to clean up resources (e.g., removing event listeners or canceling 
   - subscriptions) when the component unmounts or before the next effect runs.

   The useEffect hook is a powerful tool for managing side effects in React functional components, allowing developers to handle various 
   tasks that go beyond rendering UI elements.



45. What is fetch() and how to use it?
=> The fetch() function is a built-in JavaScript function that allows you to make network requests to retrieve resources from a server. 
   It is commonly used to fetch data from APIs and is part of the modern JavaScript ecosystem.

   The fetch() function returns a Promise that resolves to the Response object representing the response to the request. 
   You can then use methods on the Response object to extract the data in various formats, such as JSON, text, or Blob.

   Basic Syntax:
   fetch(url, options)
      .then(response => {
         // Handle the response
      })
      .catch(error => {
         // Handle any errors
      });

   Parameters:
   - url: The URL of the resource you want to fetch.
   - options (optional): An object containing any custom settings for the request, such as method (GET, POST, etc.), headers, body, etc.

   Example of Fetching JSON Data:
   fetch('https://api.example.com/data')
      .then(response => {
         if (!response.ok) {
            throw new Error('Network response was not ok ' + response.statusText);
         }
         return response.json(); // Parse the JSON from the response
      })
      .then(data => {
         console.log(data); // Handle the parsed data
      })
      .catch(error => {
         console.error('There was a problem with the fetch operation:', error);
      });

   Example of Sending Data with POST Request:
   fetch('https://api.example.com/data', {
      method: 'POST',
      headers: {
         'Content-Type': 'application/json'
      },
      body: JSON.stringify({ key: 'value' }) // Convert data to JSON string
   })
      .then(response => response.json())
      .then(data => {
         console.log('Success:', data);
      })
      .catch(error => {
         console.error('Error:', error);
      });

   The fetch() function is widely used in web development for making asynchronous requests to servers and handling responses 
   in a promise-based manner.




46. What is CORS?
=> CORS (Cross-Origin Resource Sharing) is a security feature implemented by web browsers to control how resources on a web page 
   can be requested from another domain outside the domain from which the resource originated. 
   It is a mechanism that allows servers to specify who can access their resources and how they can be accessed.

   ****For example our web app runs on localhost:1234 and we try to fetch swiggy API which is on a different domain.

   By default, web browsers enforce the Same-Origin Policy, which restricts web pages from making requests to a different domain than the one that served the web page. 
   This is done to prevent malicious websites from accessing sensitive data on other domains.

   CORS allows servers to relax this restriction by including specific HTTP headers in their responses. These headers indicate which origins are allowed to access the resources, 
   what methods are permitted (e.g., GET, POST), and what headers can be used in the request.

   Common CORS Headers:
   1. Access-Control-Allow-Origin: Specifies which origins are allowed to access the resource. It can be set to a specific origin or to "*" to allow all origins.
   2. Access-Control-Allow-Methods: Specifies the HTTP methods that are allowed when accessing the resource (e.g., GET, POST, PUT).
   3. Access-Control-Allow-Headers: Specifies which headers can be used in the actual request.
   4. Access-Control-Allow-Credentials: Indicates whether or not the response to the request can be exposed when the credentials flag is true.
   5. Access-Control-Max-Age: Indicates how long the results of a preflight request can be cached.

   Example of a CORS Response Header:
   Access-Control-Allow-Origin: https://example.com
   Access-Control-Allow-Methods: GET, POST
   Access-Control-Allow-Headers: Content-Type

   If a web application tries to make a cross-origin request that is not allowed by the server's CORS policy, 
   the browser will block the request and log an error in the console.

   In summary, CORS is an essential security feature that helps protect users and their data by controlling how resources are shared across different origins on the web.




47. What is shimmer UI?
=> Shimmer UI, also known as skeleton loading screens, is a user interface design pattern used to indicate that content is being loaded. 
   It provides a visual placeholder that mimics the structure of the actual content, giving users a sense of progress and reducing 
   perceived loading times.

   The shimmer effect typically consists of gray or light-colored blocks or lines that represent where text, images, or other elements 
   will eventually appear. 
   These placeholders often have a subtle animation, such as a gradient or moving light effect, to create the illusion of loading.

   Benefits of Shimmer UI:
   1. Improved User Experience: Shimmer UI provides immediate visual feedback to users, letting them know that content is being loaded 
                                and reducing frustration.
   2. Perceived Performance: By showing placeholders instead of a blank screen, users perceive the application as faster and more 
                             responsive.
   3. Consistency: Shimmer UI helps maintain the layout and structure of the page while content is loading, preventing layout shifts 
                   and improving overall aesthetics.

   Example Use Cases:
   - Loading lists of items (e.g., product listings, social media feeds)
   - Loading images or media content
   - Loading forms or input fields

   In React applications, libraries like "react-content-loader" can be used to easily implement shimmer effects and skeleton screens. 
   Developers can customize the appearance and animation of the placeholders to match the design of their application.

   Overall, Shimmer UI is an effective technique for enhancing user experience during content loading phases in web and mobile applications.




48. What is Optional Chaining?
=> Optional chaining is a feature in JavaScript that allows you to safely access deeply nested properties of an 
   object without having to explicitly check for the existence of each property in the chain. It is represented by the ?. operator.

   When using optional chaining, if any part of the chain is null or undefined, the entire expression will 
   short-circuit and return undefined instead of throwing an error. This makes it easier to work with complex 
   objects and avoid runtime errors.

   Basic Syntax:
   object?.property
   object?.[expression]
   object?.method()

   Example:
   const user = {
      name: 'John',
      address: {
         street: '123 Main St',
         city: 'New York'
      }
   };

   // Accessing nested properties without optional chaining
   const street = user && user.address && user.address.street; // '123 Main St'

   // Accessing nested properties with optional chaining
   const streetWithOptionalChaining = user?.address?.street; // '123 Main St'

   // Accessing a non-existent property
   const zipCode = user?.address?.zipCode; // undefined (no error thrown)

   // Calling a method that may not exist
   const greet = user?.greet?.(); // undefined (no error thrown)

   In this example, optional chaining allows us to access the street property of the address object safely. 
   If the address property were missing or null, the expression would simply return undefined instead of causing 
   an error.

   Optional chaining is particularly useful when dealing with data from APIs or external sources where the 
   structure of the data may not be guaranteed. It helps to write cleaner and more concise code by reducing the 
   need for multiple null checks.




   49. What is conditional rendering?
=> Conditional rendering in React refers to the ability to render different components or elements based on certain conditions. 
   It allows you to control what gets displayed in the UI depending on the state of your application or specific props.

   There are several ways to implement conditional rendering in React:

   1. Using if-else statements:
   You can use traditional if-else statements to determine which component or element to render.

   Example:
   function Greeting(props) {
      const isLoggedIn = props.isLoggedIn;
      if (isLoggedIn) {
         return <h1>Welcome back!</h1>;
      } else {
         return <h1>Please sign up.</h1>;
      }
   }

   2. Using ternary operators:
   Ternary operators provide a more concise way to perform conditional rendering within JSX.

   Example:
   function Greeting(props) {
      return (
         <div>
            {props.isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign up.</h1>}
         </div>
      );
   }

   3. Using logical && operator:
   You can use the logical AND (&&) operator to conditionally render an element only if a certain condition is true.

   Example:
   function Mailbox(props) {
      const unreadMessages = props.unreadMessages;
      return (
         <div>
            <h1>Hello!</h1>
            {unreadMessages.length > 0 && (
               <h2>You have {unreadMessages.length} unread messages.</h2>
            )}
         </div>
      );
   }

   4. Using switch statements:
   For more complex conditions, you can use switch statements to determine what to render.

   Example:
   function StatusMessage(props) {
      switch (props.status) {
         case 'loading':
            return <p>Loading...</p>;
         case 'success':
            return <p>Data loaded successfully!</p>;
         case 'error':
            return <p>Error loading data.</p>;
         default:
            return null;
      }
   }

   Conditional rendering is a powerful feature in React that allows you to create dynamic and interactive user 
   interfaces based on the state and props of your components.




50. Why do we need state variable instead of local variable?
=> In React, state variables are used to manage and track changes in a component's data over time, 
   while local variables are simply temporary storage within a function or component. 

   ****When state variable is updated React re-renders the respective component.****

   Here are some reasons why state variables are preferred over local variables in React:

   1. Persistence: State variables persist across re-renders of a component, meaning that their values are 
      retained even when the component updates. Local variables, on the other hand, are reset every time the 
      component re-renders.

   2. Reactivity: State variables trigger a re-render of the component when they are updated using the setState 
      function (or the updater function from useState hook). This allows the UI to automatically reflect changes 
      in the state. Local variables do not have this capability and will not cause a re-render when changed.

   3. Component Lifecycle: State variables are part of the component's lifecycle and can be initialized, updated, 
      and cleaned up as needed. Local variables do not have this lifecycle management and are limited to the scope 
      of the function or component.

   4. Data Flow: State variables facilitate data flow between components through props and state lifting. 
      Local variables cannot be passed down to child components or shared between components in the same way.

   5. Debugging and DevTools: State variables can be inspected and manipulated using React Developer Tools, making 
      it easier to debug and understand the state of your application. 
      Local variables do not have this level of visibility.

   In summary, state variables are essential for managing dynamic data in React applications, enabling reactivity, 
   persistence, and proper data flow between components. Local variables are limited in scope and functionality, 
   making them unsuitable for managing component state in React.




51. 