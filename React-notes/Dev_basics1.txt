Q1. Write Hello World using Javascript.
=> <!DOCTYPE html>
<html>
  <head>
    <title>Hello World using Javascript</title>
  </head>
  <body>
      <div id="root"></div>
      
      <script>
        const heading = document.createElement('h1');
        heading.innerHTML = "Hello World";
        
        const root = document.getElementById('root');
        root.appendChild(heading);
      </script>
  </body>
</html>


2. What is cdn?
=> A Content Delivery Network (CDN) is a globally distributed network of servers that speeds up the delivery of web content by caching it closer to users. We use CDNs to improve website performance, reduce latency, and handle high traffic loads, ensuring a faster and more reliable online experience for users worldwide 

3. What is crossorigin?
=> Cross-Origin Resource Sharing (CORS) is a security mechanism implemented by web browsers that controls how web pages can request resources from a different origin (domain, protocol, or port) than the one from which the page itself was loaded.

4. What is core react fundamental code?
=> //If we have to do multiple nesting for creating element structures, it is is difficult to maintain,
// That is why we use jsx for craeting tags
//But this is core-react


const parent = React.createElement("div", {id: "parent"},
    React.createElement("div", {id: "child"}, [
    React.createElement("h1", {}, "Hello World from Child"),
    React.createElement("h2", {}, "Hello World from Child")
    ]));

    console.log(parent);

// const heading = React.createElement("h1", { id: "heading" }, "Hello World");

const root = ReactDOM.createRoot(document.getElementById("root"));
console.log(root);

root.render(parent);

**This React.createElement() is Object.
  when we render this element into DOM, it converts to HTML and browser understands it.



5.why is react called a library and not a framework?
=> React's core responsibility is limited to the "view" layer of an application, specifically building user interfaces. 
we can inject react into specific sections also like header, footer any specific part of a website.


6. ***ReactElement is an object. => converts to HTML and browser understands it.

7. What is package.json?
=> package.json is a file that is automatically created when we create a project 
   using npm init command.
   package.json is a configuration of npm.

8. What is a bundler? (like webpack, parcel, vite)
=> A bundler is a tool that takes multiple files and combines them into a single file.
   Bundler bundles our files so that it can ship to production.

9. What is parcel?
=> Parcel is a web application bundler, similar to tools like Webpack and Rollup.
   It takes in various assets like JavaScript, CSS, HTML, and images, and processes them to create optimized bundles for deployment.

   In our vs code we run - npm install -D parcel  --> D for Dev dependency
   In package.json we can see parcel is added in dev dependency.

10. what is difference between (~2.8.3) and (^2.8.3) in package.json?
=> ~2.8.3 means it will update you to all future patch versions, but will not update you to the next minor version.
   ^2.8.3 means it will update you to all future minor/patch versions, but will not update you to the next major version.

11. What is the difference between a package.json and a package-lock.json?
=> package.json is a file that is automatically created when we create a project 
   using npm init command.
   package.json is a configuration of npm.

   package-lock.json is automatically generated for any operations where npm modifies either the node_modules tree, or package.json.
   It describes the exact tree that was generated, such that subsequent installs are able to generate identical trees, regardless of intermediate dependency updates.
   It is intended to be committed into source repositories, and serves various purposes:
     i. Describe a single representation of a dependency tree such that teammates, deployments, and continuous integration are guaranteed to install exactly the same dependencies.
    ii. Provide a facility for users to "time-travel" to previous states of node_modules without having to commit the entire directory tree.
   iii. To facilitate greater visibility of tree changes through readable diffs.


12. What is the difference between a dependency and a devDependency?
=> Dependencies are the libraries or packages that your project needs to run in a production environment.

   DevDependencies are the libraries or packages that are only needed during the development phase of project.
   These packages are not required for the application to run in a production environment.

13. What is .gitignore file? Why it is needed?
=> .gitignore is a text file that tells Git which files or directories to ignore in a project.
    It is needed to avoid committing unnecessary files, such as build artifacts, temporary files, or sensitive information, to the repository.

14. How to start a project using parcel?
=> For this project - npx parcel index.html
   npx is a package runner tool that comes with npm 5.2+ and higher.
   It is used to execute packages directly from the npm registry without having to install them globally on your system.


15. How to install react and react-dom?
=> npm install react
   npm install react-dom

16. "Browser scripts cannot have import or export." - solve it by adding type="module" in script tag in index.html
   <script type="module" src="./App.js"></script>

17. Parcel - behind the scenes
=> -Devbuild - Transpiler (babel) - converts jsx to js
   -Local server - (localhost:1234)
   -Bundler - bundles our files so that it can ship to production
   -HMR - Hot Module Replacement - reloads the page when we save the file
   -File watcher - watches for file changes (written in c++)
   -caching - Faster builds
   -Image optimization - compresses the images
   -Minification - removes unnecessary spaces, comments, etc
   -Tree shaking - removes unused code
   -consistent hashing - for long term caching
   -code splitting - splits the code into smaller chunks
   -production build - creates a production build of the app
   -Diagonostic - shows errors and warnings in the console
   -HTTPS - serves the app over HTTPS
   -Differential Bundling - creates different bundles for different browsers

18. What is Dist folder?
=> The dist folder, short for "distribution," is a directory commonly used in software development to store the final, production-ready version of a project or application.
   It typically contains optimized and minified files that are ready to be deployed to a web server or distributed to users.

19. How to know how to start a react project?
=> We can check in package.json file for the scripts section.
   e.g.-"scripts": {
         "start": "parcel index.html",
         "build": "parcel build index.html",
         "test": "jest"
         },
   Here we can see to start the project we have to run - npm run start / npm start
                                                         npm run build (for production build)

20. What is jsx?
=> JSX stands for JavaScript XML.
   Note: JSX is not a separate programming language, but rather a syntax extension for JavaScript.
         It is not part of React itself, but is commonly used with React to describe the UI structure.
         JSX is not Html inside JS. It is a syntax extension that looks similar to HTML.


21. How jsx is converted to js? 
    (e.g. <h1 id="heading">Hello World from jsx</h1>)
=> Behind the scenes, JSX is transformed into regular JavaScript function calls that create React elements.
   The transformation is typically done using a tool like Babel, which is a popular JavaScript transpiler.
   Parcel uses babel to convert jsx to React.createElement.

   JSX ==> React.createElement -JS Object ==> HTMLElement(render)   - Here Babel is converting jsx to React.createElement


23. What is transpiler?
=> A transpiler (short for "source-to-source compiler") is a type of compiler that takes source code 
   written in one programming language and transforms it into equivalent source code in another programming 
   language.
   Transpilers are commonly used to convert code from a newer version of a language to an older version, 
   or to convert code from one language to another that has similar features.



24. ***We have to use camelCase for attributes in jsx instead of lowercase.
     e.g. - class --> className
           tabindex --> tabIndex
           onclick --> onClick
           for --> htmlFor


25. ***If we write jsx in multiple lines, we have to wrap it in brackets.


26. What are components in react?
=> Components are the building blocks of a React application. They are reusable, self-contained pieces of
   code that define how a certain part of the user interface (UI) should look and behave.
   Components can be thought of as custom HTML elements that encapsulate their own structure, 
   styling, and behavior.

   i> Functional Components: These are JavaScript functions that return JSX to define the UI.
                           (A Arrow function that returns a React element) - [We can write normal function also]
                           Example:
                           const MyComponent = () => {
                             return <div>Hello, I am a functional component!</div>;
                           };

                           or if the function has only one return statement, we can write it like this:
                           const MyComponent = () => <div>Hello, I am a functional component!</div>;

                     ***How to render a functional component to the UI?
                       ==> const HeadingComponent = () => <h1>This is a Heading Component</h1>;
                           const root = ReactDOM.createRoot(document.getElementById("root"));
                           root.render(<HeadingComponent/>);  //we have to use the component as a tag


  ii> Class Based Components (older way, less used now)



27. What is component composition?
=> Component composition is a design pattern in React that allows you to build complex UIs by combining
   simpler, reusable components. It involves nesting components within other components to create a hierarchy
   of UI elements.

   Example:
   const Header = () => <header><h1>My Website</h1></header>;
   const Footer = () => <footer><p>© 2023 My Website</p></footer>;
   const MainContent = () => <main><p>Welcome to my website!</p></main>;

   const App = () => (
     <div>
       <Header />
       <MainContent />
       <Footer />
     </div>
   );

   In this example, the App component is composed of three smaller components: Header, MainContent, and Footer.
   Each of these components is responsible for rendering a specific part of the UI, and they are combined
   together in the App component to create the overall structure of the application.


28. Give example where we can inject React element in React element?
=> const elem = <span>Namaste React</span>;
   const title = (
      <h1> {elem} using JSX</h1>
   )

   const HeadingComponent = () => (
      <div id="container">
         {title}
      </div>
   )



29. What is the difference between React Element and React Component?
=> React Element: A React element is a plain JavaScript object that represents a DOM node or a component instance.
                  It is the smallest building block of a React application and describes what you want to see on the screen.
                  React elements are created using JSX or the React.createElement() method.

   React Component: A React component is a reusable piece of code that defines how a certain part of the user interface (UI) should look and behave.
                    Components can be thought of as custom HTML elements that encapsulate their own structure, styling, and behavior.
                    Components can be functional components (JavaScript functions that return JSX) or class-based components (ES6 classes that extend React.Component).

   In summary, a React element is an object that represents a DOM node or component instance, while a React component is a reusable 
   piece of code that defines the structure and behavior of a part of the UI.


30. What is Cross Site Scripting (XSS) attack? How jsx prevents it?
=> Cross-Site Scripting (XSS) is a type of security vulnerability that allows attackers to inject malicious 
scripts into web pages viewed by other users.
   JSX prevents XSS attacks by escaping any values embedded in JSX before rendering them to the DOM.
   This means that any potentially dangerous characters (like <, >, &, etc.) are converted to their 
   corresponding HTML entities (like &lt;, &gt;, &amp;, etc.), which prevents them from being interpreted 
   as executable code by the browser.



31. Describe where to use which one? - {Title()} vs <Title /> vs <Title></Title>
=> {Title()} - This syntax is used to call a regular JavaScript function named Title and embed its return value
                directly into JSX. This is typically used when Title is a function that returns a React element or
                some other value that you want to render.

   <Title /> - This syntax is used to render a React component named Title. It is a self-closing tag, which means
                that it does not have any children. This is typically used when Title is a functional or class-based
                component that you want to include in your JSX.

   <Title></Title> - This syntax is also used to render a React component named Title, but it allows you to include
                     children between the opening and closing tags. This is useful when Title is a component that
                     expects to receive child elements as props.

   In summary, use {Title()} to call a regular function and embed its return value, use <Title /> to render a 
   self-contained React component, and use <Title></Title> to render a React component that can accept child elements.


32. how to write inline css in react jsx?
=> In React JSX, we can write inline CSS styles using the style attribute, 
   but instead of a string (like in plain HTML), we pass a JavaScript object.

   Example:
      function App() {
         const boxStyle = {
         backgroundColor: "lightgreen",
   };

      return (
         <div style={boxStyle}>
            <p style={{ fontWeight: "bold" }}>This is styled with inline CSS!</p>
         </div>
      );
   }


33. What is Props?
=> ***Passing a prop to a function is like passing an argument to a function.

   Props (short for "properties") are a way to pass data from a parent component to a child component in React.
   They are read-only and allow components to be dynamic and reusable by accepting different values.

   Example:
   const Greeting = (props) => {
     return (
      <div>
      console.log(props); //props is an object
        <h1>Hello, {props.name}!</h1>;
      </div>
     )
   };

   const App = () => {
     return (
       <div>
         <Greeting name="Alice" /> //Here we are passing name="Alice" as props to Greeting component
         <Greeting name="Bob" />
       </div>
     );
   };

   In this example, the Greeting component accepts a prop called name and uses it to display a personalized greeting.
   The App component renders two instances of the Greeting component with different name props, resulting in
   "Hello, Alice!" and "Hello, Bob!" being displayed.



34. What is destructuring props on the fly?
=> Destructuring props on the fly refers to the practice of extracting specific properties from the props object
   directly within the function parameter list of a functional component in React.
   This allows for cleaner and more concise code by avoiding repetitive references to props.

   Example without destructuring:
   const Greeting = (props) => {
     return <h1>Hello, {props.name}!</h1>;
   };

   Example with destructuring on the fly:
   const Greeting = ({ name }) => {
     return <h1>Hello, {name}!</h1>;
   };

   In this example, instead of accessing the name property via props.name, we destructure it directly in the
   function parameter list by using { name }. This makes the code more readable and reduces redundancy.
   This is not React specific, it is a feature of JavaScript ES6.

   Basically this is same as:
   const Greeting = (props) => {
     const { name } = props; //destructuring
     return <h1>Hello, {name}!</h1>;
   };



35. What is Config Driven UI?
=> Config Driven UI is a design approach where the user interface (UI) of an application is
   dynamically generated based on configuration data rather than being hardcoded in the application's source code.
   This allows for greater flexibility and adaptability, as changes to the UI can be made by simply updating
   the configuration data without needing to modify the underlying code.

   Example:
   const restaurantList = [
     {
       name: "Meghana Foods",
       cuisine: ["Biryani", "North Indian", "Asian"],
       rating: "4.5",
     },
     {
       name: "KFC",
       cuisine: ["Burger", "Fast Food"],
       rating: "4.2",
     },
   ];

   const RestaurantCard = ({ resName, resCuisine }) => {
     return (
       <div className="res-card">
         <h3>{resName}</h3>
         <h4>{resCuisine}</h4>
       </div>
     );
   };

   const App = () => {
     return (
       <div className="body">
         <div className="search">Search</div>
         <div className="res-container">
           {restaurantList.map((restaurant) => (
             <RestaurantCard
               resName={restaurant.name}
               resCuisine={restaurant.cuisine.join(", ")}
             />
           ))}
         </div>
       </div>
     );
   };

   In this example, the restaurantList array serves as the configuration data that drives the UI.
   The App component maps over this array to dynamically generate RestaurantCard components for each restaurant,
   passing the relevant data as props. This way, if we want to add or remove restaurants, we can simply update
   the restaurantList array without changing the App or RestaurantCard components.



36. Take a real world scenario where data is coming through api and render it.
=> const resObj = {
         info: {
            id: "150591",
            name: "Satkar Restaurant",
            cloudinaryImageId: "rvxp5xbniat84r6efku2",
            locality: "Sinchai Colony",
            areaName: "Satkar Chowk",
            costForTwo: "₹250 for two",
            cuisines: ["South Indian", "Indian", "Salads", "Desserts"],
            avgRating: 4.4,
            veg: true,
            parentId: "21553",
            avgRatingString: "4.4",
            totalRatingsString: "3.2K+",
            sla: {
               deliveryTime: 46,
               lastMileTravel: 13.4,
               serviceability: "SERVICEABLE",
               slaString: "45-50 mins",
               lastMileTravelString: "13.4 km",
               iconType: "ICON_TYPE_EMPTY",
            },
            availability: {
               nextCloseTime: "2025-10-05 22:45:00",
               opened: true,
            },
            badges: {
               imageBadges: [
               {
                  imageId: "Rxawards/_CATEGORY-North%20Indian.png",
                  description: "Delivery!",
               },
               {
                  imageId: "Ratnesh_Badges/Rx_Awards_2025/_Milestone%20Restaurants.png",
                  description: "Delivery!",
               },
               ],
            },
            isOpen: true,
            aggregatedDiscountInfoV2: {},
            type: "F",
            badgesV2: {
               entityBadges: {
               imageBased: {
                  badgeObject: [
                     {
                     attributes: {
                        description: "Delivery!",
                        imageId: "Rxawards/_CATEGORY-North%20Indian.png",
                     },
                     },
                     {
                     attributes: {
                        description: "Delivery!",
                        imageId:
                           "Ratnesh_Badges/Rx_Awards_2025/_Milestone%20Restaurants.png",
                     },
                     },
                  ],
               },
               textBased: {},
               textExtendedBadges: {},
               },
            },
            differentiatedUi: {
               displayType: "ADS_UI_DISPLAY_TYPE_ENUM_DEFAULT",
               differentiatedUiMediaDetails: {
               lottie: {},
               video: {},
               },
            },
            reviewsSummary: {},
            displayType: "RESTAURANT_DISPLAY_TYPE_DEFAULT",
            restaurantOfferPresentationInfo: {},
            externalRatings: {
               aggregatedRating: {
               rating: "--",
               },
            },
            ratingsDisplayPreference: "RATINGS_DISPLAY_PREFERENCE_SHOW_SWIGGY",
         },
         analytics: {
            context: "seo-data-4f8d7ad2-0cfd-43a9-8d2a-31f5ac26c87b",
         },
         cta: {
            link: "https://www.swiggy.com/city/chhindwara/satkar-restaurant-sinchai-colony-satkar-chowk-rest150591",
            type: "WEBLINK",
         },
         };

   const RestaurantCard = (props) => {
   const { resData } = props;
   console.log(resData);
   return (
      <div className="res-card">
         <img
         className="res-logo"
         alt="res-logo"
         src="data:image/jpeg;base64,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"
         />
         <h3>{resData.info.name}</h3>
         <h4>{resData.info.cuisines.join(", ")}</h4>
         <h4>{resData.info.avgRating}</h4>
         <h4>{resData.info.costForTwo}</h4>
         <h4>{resData.info.sla.deliveryTime} mins</h4>
      </div>
   );
   };


   const Body = () => {
   return (
      <div className="body">
         <div className="search">Search</div>
         <div className="res-container">
         <RestaurantCard resData={resObj} />
         </div>
      </div>
   );
   };


   The body is rendered further. Here, the data is coming through an API and is stored in the resObj object.
   The RestaurantCard component takes this object as a prop and extracts the necessary information to display.




37. Why to add a unique key prop when we are rendering a list?
=> In React, when rendering a list of elements using the map() function or similar methods, it is important 
   to add a unique key prop to each element in the list. The key prop identify which items in the list have changed, 
   been added, or removed. This allows React to optimize the rendering process by only updating the parts of the DOM 
   that have actually changed, rather than re-rendering the entire list. This leads to better performance and a smoother 
   user experience.
   Index as a key is not recommended in React because the index of an item in the array can change if the array is 
   modified (e.g., items are added, removed, or reordered).

   



38. Whats are Named and Default Exports?
=> In JavaScript, modules can export values in two primary ways: named exports and default exports.

   Named Exports:
   - Named exports allow you to export multiple values from a module. Each value is exported with its own name.
   - When importing named exports, you must use the same name as the exported value and wrap it in curly braces.
   - Example of Named Export:
     // module.js
     export const foo = 'foo';
     export const bar = 'bar';

     // anotherFile.js
     import { foo, bar } from './module';

   Default Exports:
   - A default export allows you to export a single value from a module. This value can be a function, class, object, or any other type.
   - When importing a default export, you can choose any name for the imported value and do not need to use curly braces.
   - Example of Default Export:
     // module.js
     const baz = 'baz';
     export default baz;

     // anotherFile.js
     import myBaz from './module'; // You can name it anything

   You can also combine both named and default exports in a single module:
   // module.js
   export const foo = 'foo';
   export const bar = 'bar';
   const baz = 'baz';
   export default baz;

   // anotherFile.js
   import myBaz, { foo, bar } from './module';



39. What is react hooks?
=> React Hooks - Normal JS utility functions
   React Hooks are special functions that allow you to use state and other React features in functional components. 
   They were introduced in React 16.8 to enable developers to manage state and side effects without needing to convert 
   functional components into class components. Hooks provide a more concise and readable way to handle component logic.

   Some commonly used React Hooks include:
   1. useState: Allows you to add state to functional components.
   2. useEffect: Lets you perform side effects (like data fetching, subscriptions, or manually changing the DOM) in 
      functional components.
   3. useContext: Enables you to access context values without using the Context.Consumer component.
   4. useReducer: Provides an alternative to useState for managing complex state logic.
   5. useRef: Allows you to create mutable references that persist across renders, often used for accessing DOM elements.

   Example of using useState and useEffect hooks:
   import React, { useState, useEffect } from 'react';

   function Counter() {
      const [count, setCount] = useState(0);

      useEffect(() => {
         document.title = `You clicked ${count} times`;
      }, [count]); // Only re-run the effect if count changes

      return (
         <div>
            <p>You clicked {count} times</p>
            <button onClick={() => setCount(count + 1)}>
               Click me
            </button>
         </div>
      );
   }

   In this example, the Counter component uses the useState hook to manage the count state and the useEffect hook 
   to update the document title whenever the count changes.


   ****When a state variable updated React re-renders the respective component.****




40. How React works behind the scenes?
=> React is a JavaScript library for building user interfaces, and it works behind the scenes through a series of steps
   to efficiently update and render components. Here's a simplified overview of how React works:

   1. ****Virtual DOM: React uses a virtual representation of the actual DOM (Document Object Model) called the Virtual DOM. 
      This is a lightweight copy of the real DOM that allows React to make updates more efficiently.

   2. ******Reconciliation (React Fiber): When a component's state or props change, React performs a process called reconciliation. It compares 
      the new Virtual DOM with the previous version to determine what has changed. It is also knows as "Diffing".

      Diff Algorithm:
      - React uses a diffing algorithm to compare the new Virtual DOM with the previous version.
      React Fiber:
      - React Fiber is a new way of finding the differences between the two Virtual DOMs and Updates the DOM.
      - The goal of React Fiber is to enable incremental rendering (The ability to split rendering work into chunks spread it out over multiple frames) of the Virtual DOM.

   3. JSX Syntax: React uses JSX (JavaScript XML) syntax, which allows developers to write HTML-like code within JavaScript. 
      This makes it easier to create and manage UI elements.

   4. State and Props: Components can have state (data that can change over time) and props (data passed from parent 
      components). When the state or props of a component change, React triggers a re-render of that component.

   5. Component Structure: React applications are built using components, which are reusable and self-contained pieces 
      of UI. Each component can have its own state and props (properties).

   6. Efficient Updates: Instead of updating the entire DOM, React calculates the minimum number of changes needed to 
      update the real DOM based on the differences found during reconciliation. This process is known as "diffing."

   7. Batch Updates: React batches multiple updates together to optimize performance. Instead of updating the DOM immediately 
      after each change, it waits until all changes are made before applying them in one go.

   8. Rendering: Once the necessary changes are determined, React updates the real DOM with only the parts that have changed, 
      resulting in a more efficient rendering process.

   9. Event Handling: React provides a synthetic event system that normalizes events across different browsers, making it easier 
      to handle user interactions.

   10. Lifecycle Methods: Class components in React have lifecycle methods (e.g., componentDidMount, componentDidUpdate) that allow 
       developers to hook into specific points in a component's lifecycle for tasks like data fetching or cleanup.




41. Describe monolith ic and microservice architecture.
=> Monolithic Architecture:
   - In a monolithic architecture, the entire application is built as a single, unified unit. All components and functionalities 
     are tightly integrated and run within a single process.
   - Advantages:
     1. Simplicity: Easier to develop, test, and deploy as a single unit.
     2. Performance: Direct communication between components can lead to better performance.
     3. Easier to manage: Fewer moving parts to coordinate.
   - Disadvantages:
     1. Scalability: Difficult to scale individual components; the entire application must be scaled together.
     2. Maintenance: As the application grows, it can become complex and harder to maintain.
     3. Deployment: A small change requires redeploying the entire application.

   Microservices Architecture:
   - In a microservices architecture, the application is divided into smaller, independent services that communicate with each other 
     through APIs. Each service is responsible for a specific functionality and can be developed, deployed, and scaled independently.
   - Advantages:
     1. Scalability: Individual services can be scaled independently based on demand.
     2. Flexibility: Different services can use different technologies and programming languages.
     3. Resilience: Failure in one service does not necessarily affect the entire application.
     4. Faster development: Teams can work on different services simultaneously.
   - Disadvantages:
     1. Complexity: More moving parts to manage, including inter-service communication and data consistency.
     2. Deployment: Requires more sophisticated deployment strategies (e.g., containerization, orchestration).
     3. Monitoring: More challenging to monitor and debug issues across multiple services.



42. What is seperation of concerns?
=> Separation of Concerns (SoC) is a design principle in software engineering that advocates for dividing a software application 
   into distinct sections, each responsible for a specific functionality or concern. The main idea is to separate different aspects of the application 
   to improve maintainability, readability, and scalability.

   In the context of web development and React, Separation of Concerns can be applied in several ways:

   1. Component-Based Architecture: React promotes building applications using reusable components. Each component should have a single responsibility, 
      focusing on a specific part of the UI or functionality. This makes it easier to manage and update individual components without affecting others.

   2. State Management: Separating state management from UI components helps in maintaining a clear distinction between the application's data and its presentation. 
      Libraries like Redux or Context API can be used to manage state separately from the components that render the UI.

   3. Styling: Using CSS-in-JS libraries or CSS modules allows for separating styles from component logic, making it easier to manage and update styles independently.

   4. Business Logic: Keeping business logic separate from UI components ensures that the core functionality of the application is not tightly coupled with its presentation layer. 
      This can be achieved by using services or utility functions to handle business logic.

   5. File Structure: Organizing files and folders based on their purpose (e.g., components, services, utilities) helps in maintaining a clear structure and makes it easier to locate specific parts of the codebase.

   By adhering to the principle of Separation of Concerns, developers can create more modular, maintainable, and scalable applications.



43. What is single responsibility principle?
=> The Single Responsibility Principle (SRP) is one of the five SOLID principles of object-oriented design. It states that a class or 
   module should have only one reason to change, meaning it should have only one responsibility or job.

   In the context of software development, adhering to the Single Responsibility Principle helps in creating more maintainable, understandable, and testable code. 
   When a class or module has a single responsibility, it becomes easier to modify or extend its functionality without affecting other parts of the codebase.

   In React development, the Single Responsibility Principle can be applied by ensuring that each component has a specific purpose and does not handle multiple concerns. 
   For example, a component should focus on rendering UI elements and managing its own state, while business logic and data fetching should be handled by separate services or hooks.

   Benefits of following the Single Responsibility Principle include:
   1. Improved maintainability: Changes to one part of the code are less likely to impact other parts.
   2. Easier testing: Components with a single responsibility are easier to test in isolation.
   3. Enhanced readability: Code is more understandable when each component has a clear purpose.
   4. Better reusability: Components can be reused in different contexts without bringing along unnecessary functionality.

   Overall, the Single Responsibility Principle encourages developers to create modular and focused components, leading to cleaner and more efficient codebases.



44. What is useEffect hook?
=> The useEffect hook is a built-in React hook that allows you to perform side effects in functional components. 
   Side effects are operations that can affect other parts of the application or interact with external systems, 
   such as fetching data from an API, updating the DOM, setting up subscriptions, or managing timers.

   ****useEffect is called after the component has rendered.

   ****** if no dependency array => useEffect is called after every render.
   ****** if empty dependency array => useEffect is called only once after the initial render (componentDidMount).
   ****** if dependency array with variables => useEffect is called only when any of the variables in the array change.

   The useEffect hook takes two arguments:
   1. A Arrow function that contains the side effect logic. This function is executed after the component renders.
   2. An optional dependency array that specifies when the effect should be re-run. If any value in the dependency 
      array changes, the effect will be re-executed.

   Basic Syntax:
   import React, { useEffect } from 'react';

   function MyComponent() {
      useEffect(() => {
         // Side effect logic here (e.g., data fetching, subscriptions)
         console.log('Component mounted or updated');

         // Optional cleanup function
         return () => {
            console.log('Component unmounted or before next effect');
         };
      }, []); // Empty dependency array means this effect runs only once on mount

      return <div>My Component</div>;
   }

   Key Points:
   - If you provide an empty dependency array ([]), the effect will run only once when the component mounts and not on subsequent updates.
   - If you provide a dependency array with specific values ([prop1, state1]), the effect will run whenever any of those values change.
   - If you omit the dependency array altogether, the effect will run after every render, which can lead to performance issues if not 
   - managed carefully.
   - The cleanup function (returned from the effect function) is used to clean up resources (e.g., removing event listeners or canceling 
   - subscriptions) when the component unmounts or before the next effect runs.

   The useEffect hook is a powerful tool for managing side effects in React functional components, allowing developers to handle various 
   tasks that go beyond rendering UI elements.



45. What is fetch() and how to use it?
=> The fetch() function is a built-in JavaScript function that allows you to make network requests to retrieve resources from a server. 
   It is commonly used to fetch data from APIs and is part of the modern JavaScript ecosystem.

   The fetch() function returns a Promise that resolves to the Response object representing the response to the request. 
   You can then use methods on the Response object to extract the data in various formats, such as JSON, text, or Blob.

   Basic Syntax:
   fetch(url, options)
      .then(response => {
         // Handle the response
      })
      .catch(error => {
         // Handle any errors
      });

   Parameters:
   - url: The URL of the resource you want to fetch.
   - options (optional): An object containing any custom settings for the request, such as method (GET, POST, etc.), headers, body, etc.

   Example of Fetching JSON Data:
   fetch('https://api.example.com/data')
      .then(response => {
         if (!response.ok) {
            throw new Error('Network response was not ok ' + response.statusText);
         }
         return response.json(); // Parse the JSON from the response
      })
      .then(data => {
         console.log(data); // Handle the parsed data
      })
      .catch(error => {
         console.error('There was a problem with the fetch operation:', error);
      });

   Example of Sending Data with POST Request:
   fetch('https://api.example.com/data', {
      method: 'POST',
      headers: {
         'Content-Type': 'application/json'
      },
      body: JSON.stringify({ key: 'value' }) // Convert data to JSON string
   })
      .then(response => response.json())
      .then(data => {
         console.log('Success:', data);
      })
      .catch(error => {
         console.error('Error:', error);
      });

   The fetch() function is widely used in web development for making asynchronous requests to servers and handling responses 
   in a promise-based manner.




46. What is CORS?
=> CORS (Cross-Origin Resource Sharing) is a security feature implemented by web browsers to control how resources on a web page 
   can be requested from another domain outside the domain from which the resource originated. 
   It is a mechanism that allows servers to specify who can access their resources and how they can be accessed.

   ****For example our web app runs on localhost:1234 and we try to fetch swiggy API which is on a different domain.

   By default, web browsers enforce the Same-Origin Policy, which restricts web pages from making requests to a different domain than the one that served the web page. 
   This is done to prevent malicious websites from accessing sensitive data on other domains.

   CORS allows servers to relax this restriction by including specific HTTP headers in their responses. These headers indicate which origins are allowed to access the resources, 
   what methods are permitted (e.g., GET, POST), and what headers can be used in the request.

   Common CORS Headers:
   1. Access-Control-Allow-Origin: Specifies which origins are allowed to access the resource. It can be set to a specific origin or to "*" to allow all origins.
   2. Access-Control-Allow-Methods: Specifies the HTTP methods that are allowed when accessing the resource (e.g., GET, POST, PUT).
   3. Access-Control-Allow-Headers: Specifies which headers can be used in the actual request.
   4. Access-Control-Allow-Credentials: Indicates whether or not the response to the request can be exposed when the credentials flag is true.
   5. Access-Control-Max-Age: Indicates how long the results of a preflight request can be cached.

   Example of a CORS Response Header:
   Access-Control-Allow-Origin: https://example.com
   Access-Control-Allow-Methods: GET, POST
   Access-Control-Allow-Headers: Content-Type

   If a web application tries to make a cross-origin request that is not allowed by the server's CORS policy, 
   the browser will block the request and log an error in the console.

   In summary, CORS is an essential security feature that helps protect users and their data by controlling how resources are shared across different origins on the web.




47. What is shimmer UI?
=> Shimmer UI, also known as skeleton loading screens, is a user interface design pattern used to indicate that content is being loaded. 
   It provides a visual placeholder that mimics the structure of the actual content, giving users a sense of progress and reducing 
   perceived loading times.

   The shimmer effect typically consists of gray or light-colored blocks or lines that represent where text, images, or other elements 
   will eventually appear. 
   These placeholders often have a subtle animation, such as a gradient or moving light effect, to create the illusion of loading.

   Benefits of Shimmer UI:
   1. Improved User Experience: Shimmer UI provides immediate visual feedback to users, letting them know that content is being loaded 
                                and reducing frustration.
   2. Perceived Performance: By showing placeholders instead of a blank screen, users perceive the application as faster and more 
                             responsive.
   3. Consistency: Shimmer UI helps maintain the layout and structure of the page while content is loading, preventing layout shifts 
                   and improving overall aesthetics.

   Example Use Cases:
   - Loading lists of items (e.g., product listings, social media feeds)
   - Loading images or media content
   - Loading forms or input fields

   In React applications, libraries like "react-content-loader" can be used to easily implement shimmer effects and skeleton screens. 
   Developers can customize the appearance and animation of the placeholders to match the design of their application.

   Overall, Shimmer UI is an effective technique for enhancing user experience during content loading phases in web and mobile applications.




48. What is Optional Chaining?
=> Optional chaining is a feature in JavaScript that allows you to safely access deeply nested properties of an 
   object without having to explicitly check for the existence of each property in the chain. It is represented by the ?. operator.

   When using optional chaining, if any part of the chain is null or undefined, the entire expression will 
   short-circuit and return undefined instead of throwing an error. This makes it easier to work with complex 
   objects and avoid runtime errors.

   Basic Syntax:
   object?.property
   object?.[expression]
   object?.method()

   Example:
   const user = {
      name: 'John',
      address: {
         street: '123 Main St',
         city: 'New York'
      }
   };

   // Accessing nested properties without optional chaining
   const street = user && user.address && user.address.street; // '123 Main St'

   // Accessing nested properties with optional chaining
   const streetWithOptionalChaining = user?.address?.street; // '123 Main St'

   // Accessing a non-existent property
   const zipCode = user?.address?.zipCode; // undefined (no error thrown)

   // Calling a method that may not exist
   const greet = user?.greet?.(); // undefined (no error thrown)

   In this example, optional chaining allows us to access the street property of the address object safely. 
   If the address property were missing or null, the expression would simply return undefined instead of causing 
   an error.

   Optional chaining is particularly useful when dealing with data from APIs or external sources where the 
   structure of the data may not be guaranteed. It helps to write cleaner and more concise code by reducing the 
   need for multiple null checks.




49. What is conditional rendering?
=> Conditional rendering in React refers to the ability to render different components or elements based on certain conditions. 
   It allows you to control what gets displayed in the UI depending on the state of your application or specific props.

   There are several ways to implement conditional rendering in React:

   1. Using if-else statements:
   You can use traditional if-else statements to determine which component or element to render.

   Example:
   function Greeting(props) {
      const isLoggedIn = props.isLoggedIn;
      if (isLoggedIn) {
         return <h1>Welcome back!</h1>;
      } else {
         return <h1>Please sign up.</h1>;
      }
   }

   2. Using ternary operators:
   Ternary operators provide a more concise way to perform conditional rendering within JSX.

   Example:
   function Greeting(props) {
      return (
         <div>
            {props.isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign up.</h1>}
         </div>
      );
   }

   3. Using logical && operator:
   You can use the logical AND (&&) operator to conditionally render an element only if a certain condition is true.

   Example:
   function Mailbox(props) {
      const unreadMessages = props.unreadMessages;
      return (
         <div>
            <h1>Hello!</h1>
            {unreadMessages.length > 0 && (
               <h2>You have {unreadMessages.length} unread messages.</h2>
            )}
         </div>
      );
   }

   4. Using switch statements:
   For more complex conditions, you can use switch statements to determine what to render.

   Example:
   function StatusMessage(props) {
      switch (props.status) {
         case 'loading':
            return <p>Loading...</p>;
         case 'success':
            return <p>Data loaded successfully!</p>;
         case 'error':
            return <p>Error loading data.</p>;
         default:
            return null;
      }
   }

   Conditional rendering is a powerful feature in React that allows you to create dynamic and interactive user 
   interfaces based on the state and props of your components.




50. Why do we need state variable instead of local variable?
=> In React, state variables are used to manage and track changes in a component's data over time, 
   while local variables are simply temporary storage within a function or component. 

   ****When state variable is updated React re-renders the respective component(reconciliation).****

   Here are some reasons why state variables are preferred over local variables in React:

   1. Persistence: State variables persist across re-renders of a component, meaning that their values are 
      retained even when the component updates. Local variables, on the other hand, are reset every time the 
      component re-renders.

   2. Reactivity: State variables trigger a re-render of the component when they are updated using the setState 
      function (or the updater function from useState hook). This allows the UI to automatically reflect changes 
      in the state. Local variables do not have this capability and will not cause a re-render when changed.

   3. Component Lifecycle: State variables are part of the component's lifecycle and can be initialized, updated, 
      and cleaned up as needed. Local variables do not have this lifecycle management and are limited to the scope 
      of the function or component.

   4. Data Flow: State variables facilitate data flow between components through props and state lifting. 
      Local variables cannot be passed down to child components or shared between components in the same way.

   5. Debugging and DevTools: State variables can be inspected and manipulated using React Developer Tools, making 
      it easier to debug and understand the state of your application. 
      Local variables do not have this level of visibility.

   In summary, state variables are essential for managing dynamic data in React applications, enabling reactivity, 
   persistence, and proper data flow between components. Local variables are limited in scope and functionality, 
   making them unsuitable for managing component state in React.




51. What is React Router DOM?
=> React Router DOM is a popular library used in React applications to handle routing and navigation.
   It allows developers to create single-page applications (SPAs) with multiple views or pages, enabling users to 
   navigate between different components without triggering a full page reload.

   Install it using npm or yarn:
   npm install react-router-dom

   Describe the main components of React Router DOM:
   1. BrowserRouter: This component is used to wrap the entire application and provides the routing context. 
                     It uses the HTML5 history API to keep the UI in sync with the URL.
   2. Route: This component is used to define a mapping between a URL path and a React component. When the URL 
            matches the specified path, the corresponding component is rendered.
   3. Link: This component is used to create navigational links that allow users to navigate to different routes 
            without causing a full page reload.
   4. createBrowserRouter: This function is used to create a router instance that can be passed to the 
                           RouterProvider component.
   5. RouterProvider: This component is used to provide the router instance to the application.
   6. Outlet: This component is used to render child routes within a parent route.

   ***What is child route?***
   Child routes are nested routes that are defined within a parent route. They allow you to create a hierarchical 
   structure of routes, where a parent route can have multiple child routes. This is useful for organizing related 
   views and components within an application.

   ****State the difference between Link and anchor tag?****
   - Link is a component provided by React Router DOM that allows for client-side navigation without causing a full page reload.
   - Anchor tag (<a>) is a standard HTML element that causes a full page reload when clicked.

   **Never use anchor tag for navigation in React applications. Always use Link component from React Router DOM.**


   ****Routing types in web applications:****
   1. Client-Side Routing: In client-side routing, the routing logic is handled on the client side (browser) 
      using JavaScript. When a user navigates to a different route, the application dynamically updates the 
      content without reloading the entire page. This is commonly used in single-page applications (SPAs) built 
      with frameworks like React, Angular, or Vue.js.

   2. Server-Side Routing: In server-side routing, the routing logic is handled on the server side. When a user 
      navigates to a different route,the server processes the request and sends back a new HTML page. This approach 
      is typically used in traditional multi-page applications (MPAs) where each route corresponds to a separate 
      HTML file.Examples include applications built with frameworks like Django, Ruby on Rails, or Express.js.




52. What is Single Page Application?
=> A Single Page Application (SPA) is a web application that loads a single HTML page and dynamically updates the content 
   as the user interacts with the app, without requiring a full page reload. SPAs provide a more fluid and responsive user experience, 
   similar to that of a desktop application.

   Key Characteristics of SPAs:
   1. Single HTML Page: The entire application is served as a single HTML file, and JavaScript is used to manage the content and 
      navigation within the app.
   2. Dynamic Content Loading: SPAs use AJAX (Asynchronous JavaScript and XML) or Fetch API to load data and content dynamically from 
      the server without refreshing the entire page.
   3. Client-Side Routing: SPAs often use client-side routing libraries (like React Router) to manage navigation between different views 
      or components within the app.
   4. Improved User Experience: By avoiding full page reloads, SPAs can provide a smoother and faster user experience, with less waiting time 
      for content to load.
   5. State Management: SPAs often require state management solutions (like Redux or Context API) to handle complex application states across 
      different components.

   Examples of Popular SPA Frameworks/Libraries:
   - React
   - Angular
   - Vue.js

   Benefits of SPAs:
   - Faster interactions and transitions between views
   - Reduced server load due to fewer full page requests
   - Enhanced user experience with seamless navigation

   Challenges of SPAs:
   - Initial load time can be longer due to loading all necessary resources upfront
   - SEO (Search Engine Optimization) can be more challenging, although techniques like server-side rendering (SSR) can help mitigate this issue
   - More complex client-side codebase that requires careful management of state and routing

   Overall, Single Page Applications are widely used in modern web development for creating dynamic and interactive user interfaces.




53. What is the difference between <Link> and <a> tag?
=> The main difference between the <Link> component from React Router DOM and the traditional <a> tag in HTML lies in how they handle 
   navigation within a web application.

   1. <Link> Component:
      - The <Link> component is specifically designed for client-side routing in React applications.
      - It allows for navigation between different routes without causing a full page reload.
      - When a user clicks on a <Link>, React Router intercepts the click event and updates the URL and the displayed content 
        dynamically, keeping the application state intact.
      - Example:
        <Link to="/about">About</Link>

   2. <a> Tag:
      - The <a> tag is a standard HTML element used for creating hyperlinks to other web pages or resources.
      - When a user clicks on an <a> tag, the browser performs a full page reload and navigates to the specified URL.
      - This results in losing the current application state and can lead to a less smooth user experience in single-page applications (SPAs).
      - Example:
        <a href="/about">About</a>

   In summary, use the <Link> component for navigation within React applications to take advantage of client-side routing and avoid full page reloads. 
   Use the <a> tag for linking to external websites or resources outside of your React application.





54. What is useParams hook?
=> The useParams hook is a built-in React Router hook that allows you to access the parameters of the current route in a functional component. 
   It is commonly used when you have dynamic segments in your URL, such as user IDs or product IDs, and you want to retrieve those values 
   to display specific content based on the route.

   Basic Syntax:
   import { useParams } from 'react-router-dom';

   function MyComponent() {
      const params = useParams();
      // Access route parameters using params object
   }

   Example:
   Consider a route defined as follows:
   <Route path="/user/:userId" component={UserProfile} />

   In the UserProfile component, you can use the useParams hook to access the userId parameter from the URL:
   import React from 'react';
   import { useParams } from 'react-router-dom';

   function UserProfile() {
      const { userId } = useParams();

      return (
         <div>
            <h1>User Profile</h1>
            <p>User ID: {userId}</p>
         </div>
      );
   }

   In this example, when a user navigates to /user/123, the UserProfile component will display "User ID: 123".

   The useParams hook is a convenient way to extract route parameters and use them within your components, enabling dynamic rendering based on the URL.





55. What is ClassBased Component?
=> Class-Based Components are one of the two main ways to define components in React, the other being Functional Components. 
   Class-Based Components are defined using ES6 classes and extend the React.Component class. They have access to lifecycle methods 
   and can manage their own state.

   Key Features of Class-Based Components:
   1. State Management: Class-Based Components can have their own state, which is managed using this.state and updated using this.setState().
   2. Lifecycle Methods: Class-Based Components have access to various lifecycle methods (e.g., componentDidMount, componentDidUpdate, componentWillUnmount) 
      that allow developers to hook into specific points in the component's lifecycle for tasks like data fetching or cleanup.
   3. Render Method: Class-Based Components must implement a render() method that returns the JSX to be rendered to the DOM.
   4. 'this' Keyword: In Class-Based Components, 'this' refers to the instance of the component, allowing access to props, state, and methods.

   Example of a Class-Based Component:
   import React, { Component } from 'react';

   class MyComponent extends Component {
      constructor(props) {
         super(props);
         this.state = {
            count: 0
         };
      }

      increment = () => {
         this.setState({ count: this.state.count + 1 });
      };

      render() {
         return (
            <div>
               <p>Count: {this.state.count}</p>
               <button onClick={this.increment}>Increment</button>
            </div>
         );
      }
   }

   In this example, MyComponent is a Class-Based Component that manages its own state (count) and provides a button to increment the count value.










56. What is the difference between ClassBased Component and Functional Component?
=> The main differences between Class-Based Components and Functional Components in React are as follows:

   1. Syntax:
      - Class-Based Components are defined using ES6 classes and extend the React.Component class.
      - Functional Components are defined as plain JavaScript functions that return JSX.

   2. State Management:
      - Class-Based Components can manage their own state using this.state and update it with this.setState().
      - Functional Components can manage state using the useState hook.

   3. Lifecycle Methods:
      - Class-Based Components have access to lifecycle methods (e.g., componentDidMount, componentDidUpdate) for managing side effects.
      - Functional Components use the useEffect hook to handle side effects and lifecycle events.

   4. 'this' Keyword:
      - In Class-Based Components, 'this' refers to the instance of the component, allowing access to props, state, and methods.
      - In Functional Components, there is no 'this' context; props and state are accessed directly.

   5. Performance:
      - Functional Components are generally considered more lightweight and can lead to better performance due to optimizations like React's 
        memoization (React.memo).
      - Class-Based Components may have a slightly higher overhead due to the class structure.

   6. Readability and Maintainability:
      - Functional Components are often seen as more concise and easier to read, especially with the introduction of hooks.
      - Class-Based Components can become more complex with larger components due to the need for binding methods and managing state.

   Overall, both Class-Based and Functional Components have their use cases, but with the introduction of hooks, Functional Components have become 
   the preferred choice for many developers due to their simplicity and flexibility.














57. How to convert ClassBased Component to Functional Component?
=> To convert a Class-Based Component to a Functional Component, you need to follow these steps:

   1. Change the component definition from a class to a function.
   2. Remove the constructor and use the useState hook to manage state.
   3. Replace lifecycle methods with the useEffect hook for side effects.
   4. Update event handlers to use arrow functions or bind them directly in JSX.

   Example Conversion:

   Class-Based Component:
   import React, { Component } from 'react';

   class MyComponent extends Component {
      constructor(props) {
         super(props);
         this.state = {
            count: 0
         };
      }

      increment = () => {
         this.setState({ count: this.state.count + 1 });
      };

      render() {
         return (
            <div>
               <p>Count: {this.state.count}</p>
               <button onClick={this.increment}>Increment</button>
            </div>
         );
      }
   }













   
58. What is the purpose of using a constructor in a React class component?
=> The constructor is used to initialize the component’s state and bind methods before the component mounts. 
   It’s the first function called when the component is created.


59. Why do we need to call super() inside the constructor?
=> Because the component class extends React.Component, it’s a subclass. In JavaScript, when you define a constructor 
   in a subclass, you must call super() before using this, otherwise it will cause an error.



60.What does super(props) do?
=> It calls the constructor of the parent class (React.Component) and passes the props to it. 
   This ensures that this.props is correctly initialized and available inside your component.



61. What happens if we call super() without passing props?
=> If you call super() without props, this.props will be undefined inside the constructor. You can still access props outside the 
   constructor (e.g., in render()), but not within the constructor itself.



62. When do we actually need a constructor in React class components?
=> Only when you need to:

   Initialize this.state

   Bind class methods
   If you’re not doing either, you can omit the constructor entirely.



63. What happens if we don’t write a constructor at all?
=> React automatically calls the parent class constructor (super(props)) behind the scenes, 
   so this.props still works normally in your component.



64. How to use state in ClassBased Component?
=> In a ClassBased Component, state is typically initialized in the constructor using this.state. For example:
   class MyComponent extends React.Component {
   constructor(props) {
      super(props);
      this.state = {
         count: 0
      };
   }

   render() {
      return (
         <div>
         <p>Count: {this.state.count}</p>
         </div>
      );
   }
   }


65. What is the order of life cycle method calls in Class Based Components ?
=> The order of lifecycle method calls in Class-Based Components is as follows:

   1. Mounting Phase:
      - constructor() - The constructor method is the first to be called when a component is created. 
                        It's where we typically initialize the component's state and bind event handlers. 
      - render() -      The render method is responsible for rendering the component's UI. It must return a React element 
                        (typically JSX) representing the component's structure.
      - componentDidMount() - This method is called immediately after the component is inserted into the DOM. It's often used for 
                              making AJAX requests, setting up subscriptions, or other one-time initializations.

   2. Updating Phase (when props or state change):
      - render() - The render method is called again to update the component's UI based on the new props or state.
      - componentDidUpdate() - This method is called after the component has been updated (re-rendered) due to changes in state or props. 
                               It's often used for side effects, like Episode-08 | Let’s Get Classy 6 updating the DOM in response to state or prop changes.

   3. Unmounting Phase:
      - componentWillUnmount() - This method is called just before the component is removed from the DOM. 
                                 It's typically used for cleanup tasks, such as removing event listeners or canceling network requests.

   Note: Some lifecycle methods are rarely used and are considered legacy, such as componentWillMount(), componentWillReceiveProps(), 
   and componentWillUpdate(). It is recommended to use the newer lifecycle methods instead.

   Reference: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/









66. Why do we use componentDidMount ?
=> The  componentDidMount  lifecycle method in React class-based components is used for a specific purpose: it is called 
   immediately after a component is inserted into the DOM (Document Object Model). This makes it a crucial point in the component's 
   lifecycle and provides a valuable opportunity to perform various tasks that require interaction with the DOM or external data sources.

   Fetching Data - It's often used to make asynchronous requests to fetch data from APIs or external sources. This is a common scenario 
                   for components that need to display dynamic content.

   DOM Manipulation - When we need to interact with the DOM directly, such as selecting elements, setting attributes, or applying 
                      third-party libraries that require DOM elements to be present, we can safely do so in componentDidMount. This is because the 
                      component is guaranteed to be in the DOM at this point. 





67. Why do we use componentWillUnmount ? Show with example.
=> The componentWillUnmount lifecycle method in React class-based components is used for cleanup tasks just before a component is removed from the DOM. 
   This method is essential for preventing memory leaks and ensuring that any resources or subscriptions created during the component's lifecycle are properly released.

   Common use cases for componentWillUnmount include:

   1. Removing Event Listeners: If your component has added event listeners (e.g., window resize, scroll events), 
      you should remove them in componentWillUnmount to avoid memory leaks.

   2. Canceling Network Requests: If your component initiated any asynchronous network requests (e.g., fetching data from an API), 
      you should cancel those requests in componentWillUnmount to prevent state updates on unmounted components.

   3. Cleaning Up Subscriptions: If your component subscribed to external data sources (e.g., WebSocket connections, Redux store), 
      you should unsubscribe in componentWillUnmount to avoid unnecessary updates.

   Example:
   class MyComponent extends React.Component {
      componentDidMount() {
         // Adding an event listener
         window.addEventListener('resize', this.handleResize);
      }

      componentWillUnmount() {
         // Removing the event listener
         window.removeEventListener('resize', this.handleResize);
      }

      handleResize = () => {
         console.log('Window resized');
      };

      render() {
         return <div>My Component</div>;
      }
   }




68. What is Single Responsibility Principle?
=> The Single Responsibility Principle (SRP) is a fundamental concept in software design and development that states that a class, module, 
   or function should have only one reason to change. 
   In other words, it should be responsible for a single functionality or concern.

   The idea behind SRP is to promote modularity, maintainability, and readability in code. 
   When a component adheres to SRP, it becomes easier to understand, test, and modify without affecting other parts of the system.

   Benefits of Single Responsibility Principle:
   1. Improved Maintainability: When a component has a single responsibility, it is easier to locate and fix bugs or make changes without impacting other functionalities.
   2. Enhanced Readability: Code that follows SRP is often more straightforward and easier to comprehend, as each component has a clear purpose.
   3. Easier Testing: Components with a single responsibility can be tested in isolation, making unit testing more effective and efficient.
   4. Reduced Complexity: By breaking down complex systems into smaller, focused components, SRP helps reduce overall complexity and makes the codebase more manageable.

   Example:
   Consider a class that handles both user authentication and data retrieval. 
   According to SRP, it would be better to separate these responsibilities into two distinct classes: 
   one for authentication and another for data retrieval. This way, changes to the authentication logic won't affect the data retrieval logic and vice versa.

   In summary, the Single Responsibility Principle is a key principle in software design that encourages developers to create components 
   with focused responsibilities, leading to cleaner and more maintainable code.


69. What is Dynamic bundling or Chunking or lazy loading or on demand loading?
=> Dynamic bundling, also known as code splitting or chunking, is a technique used in web development to optimize the loading of JavaScript 
   and other assets in a web application. It involves breaking down the application's code into smaller, manageable chunks or bundles that can be 
   loaded on demand, rather than loading the entire application at once.

   The main goal of dynamic bundling is to improve the performance and user experience of web applications by reducing the initial load time and 
   allowing users to access content more quickly. By loading only the necessary code for a specific route or feature, dynamic bundling helps minimize 
   the amount of data that needs to be transferred over the network.

   Benefits of Dynamic Bundling:
   1. Faster Initial Load: Users can start interacting with the application sooner since only essential code is loaded initially.
   2. Reduced Bandwidth Usage: By loading only the required code, dynamic bundling reduces the amount of data transferred, which is especially beneficial for users on slow or limited connections.
   3. Improved Caching: Smaller bundles can be cached more effectively by browsers, leading to faster subsequent loads.
   4. Better User Experience: Users experience less waiting time and smoother navigation as they interact with different parts of the application.

   Implementation:
   Dynamic bundling can be implemented using various tools and libraries, such as Webpack's code splitting feature or React's lazy loading with React.lazy and Suspense. 
   These tools allow developers to define how and when different parts of the application should be loaded based on user interactions or specific routes.

   In summary, dynamic bundling is a powerful technique for optimizing web applications by breaking down code into smaller chunks that can be loaded on demand, 
   leading to improved performance and user experience.




70. What is React Lazy and Suspense?
=> React.lazy and Suspense are features in React that enable code splitting and lazy loading of components. 
   They allow developers to load components only when they are needed, which can improve the performance of React applications by reducing the initial load time.

   React.lazy:
   React.lazy is a function that allows you to define a component that is loaded dynamically. 
   It takes a function that returns a promise (usually an import statement) and returns a React component that can be rendered.

   Example:
   import React, { Suspense } from 'react';

   const LazyComponent = React.lazy(() => import('./LazyComponent'));

   function App() {
      return (
         <div>
            <Suspense fallback={<div>Loading...</div>}>
               <LazyComponent />
            </Suspense>
         </div>
      );
   }

   In this example, LazyComponent is loaded only when it is rendered, and while it is loading, the fallback content ("Loading...") is displayed.

   Suspense:
   Suspense is a component that allows you to specify a loading state while waiting for a lazy-loaded component to be ready. 
   It wraps around the lazy-loaded component and provides a fallback UI that is displayed until the component has finished loading.

   The combination of React.lazy and Suspense makes it easy to implement code splitting in React applications, allowing for better performance and user experience by loading components on demand.









71. 

   
