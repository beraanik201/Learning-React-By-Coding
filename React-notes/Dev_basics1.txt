Q1. Write Hello World using Javascript.
=> <!DOCTYPE html>
<html>
  <head>
    <title>Hello World using Javascript</title>
  </head>
  <body>
      <div id="root"></div>
      
      <script>
        const heading = document.createElement('h1');
        heading.innerHTML = "Hello World";
        
        const root = document.getElementById('root');
        root.appendChild(heading);
      </script>
  </body>
</html>


2. What is cdn?
=> A Content Delivery Network (CDN) is a globally distributed network of servers that speeds up the delivery of web content by caching it closer to users. We use CDNs to improve website performance, reduce latency, and handle high traffic loads, ensuring a faster and more reliable online experience for users worldwide 

3. What is crossorigin?
=> Cross-Origin Resource Sharing (CORS) is a security mechanism implemented by web browsers that controls how web pages can request resources from a different origin (domain, protocol, or port) than the one from which the page itself was loaded.

4. What is core react fundamental code?
=> //If we have to do multiple nesting for creating element structures, it is is difficult to maintain,
// That is why we use jsx for craeting tags
//But this is core-react


const parent = React.createElement("div", {id: "parent"},
    React.createElement("div", {id: "child"}, [
    React.createElement("h1", {}, "Hello World from Child"),
    React.createElement("h2", {}, "Hello World from Child")
    ]));

    console.log(parent);

// const heading = React.createElement("h1", { id: "heading" }, "Hello World");

const root = ReactDOM.createRoot(document.getElementById("root"));
console.log(root);

root.render(parent);

**This React.createElement() is Object.
  when we render this element into DOM, it converts to HTML and browser understands it.



5.why is react called a library and not a framework?
=> React's core responsibility is limited to the "view" layer of an application, specifically building user interfaces. 
we can inject react into specific sections also like header, footer any specific part of a website.


6. ***ReactElement is an object. => converts to HTML and browser understands it.

7. What is package.json?
=> package.json is a file that is automatically created when we create a project 
   using npm init command.
   package.json is a configuration of npm.

8. What is a bundler? (like webpack, parcel, vite)
=> A bundler is a tool that takes multiple files and combines them into a single file.
   Bundler bundles our files so that it can ship to production.

9. What is parcel?
=> Parcel is a web application bundler, similar to tools like Webpack and Rollup.
   It takes in various assets like JavaScript, CSS, HTML, and images, and processes them to create optimized bundles for deployment.

   In our vs code we run - npm install -D parcel  --> D for Dev dependency
   In package.json we can see parcel is added in dev dependency.

10. what is difference between (~2.8.3) and (^2.8.3) in package.json?
=> ~2.8.3 means it will update you to all future patch versions, but will not update you to the next minor version.
   ^2.8.3 means it will update you to all future minor/patch versions, but will not update you to the next major version.

11. What is the difference between a package.json and a package-lock.json?
=> package.json is a file that is automatically created when we create a project 
   using npm init command.
   package.json is a configuration of npm.

   package-lock.json is automatically generated for any operations where npm modifies either the node_modules tree, or package.json.
   It describes the exact tree that was generated, such that subsequent installs are able to generate identical trees, regardless of intermediate dependency updates.
   It is intended to be committed into source repositories, and serves various purposes:
     i. Describe a single representation of a dependency tree such that teammates, deployments, and continuous integration are guaranteed to install exactly the same dependencies.
    ii. Provide a facility for users to "time-travel" to previous states of node_modules without having to commit the entire directory tree.
   iii. To facilitate greater visibility of tree changes through readable diffs.


12. What is the difference between a dependency and a devDependency?
=> Dependencies are the libraries or packages that your project needs to run in a production environment.

   DevDependencies are the libraries or packages that are only needed during the development phase of project.
   These packages are not required for the application to run in a production environment.

13. What is .gitignore file? Why it is needed?
=> .gitignore is a text file that tells Git which files or directories to ignore in a project.
    It is needed to avoid committing unnecessary files, such as build artifacts, temporary files, or sensitive information, to the repository.

14. How to start a project using parcel?
=> For this project - npx parcel index.html
   npx is a package runner tool that comes with npm 5.2+ and higher.
   It is used to execute packages directly from the npm registry without having to install them globally on your system.


15. How to install react and react-dom?
=> npm install react
   npm install react-dom

16. "Browser scripts cannot have import or export." - solve it by adding type="module" in script tag in index.html
   <script type="module" src="./App.js"></script>

17. Parcel - behind the scenes
=> -Devbuild - Transpiler (babel) - converts jsx to js
   -Local server - (localhost:1234)
   -Bundler - bundles our files so that it can ship to production
   -HMR - Hot Module Replacement - reloads the page when we save the file
   -File watcher - watches for file changes (written in c++)
   -caching - Faster builds
   -Image optimization - compresses the images
   -Minification - removes unnecessary spaces, comments, etc
   -Tree shaking - removes unused code
   -consistent hashing - for long term caching
   -code splitting - splits the code into smaller chunks
   -production build - creates a production build of the app
   -Diagonostic - shows errors and warnings in the console
   -HTTPS - serves the app over HTTPS
   -Differential Bundling - creates different bundles for different browsers

18. What is Dist folder?
=> The dist folder, short for "distribution," is a directory commonly used in software development to store the final, production-ready version of a project or application.
   It typically contains optimized and minified files that are ready to be deployed to a web server or distributed to users.

19. How to know how to start a react project?
=> We can check in package.json file for the scripts section.
   e.g.-"scripts": {
         "start": "parcel index.html",
         "build": "parcel build index.html",
         "test": "jest"
         },
   Here we can see to start the project we have to run - npm run start / npm start
                                                         npm run build (for production build)

20. What is jsx?
=> JSX stands for JavaScript XML.
   Note: JSX is not a separate programming language, but rather a syntax extension for JavaScript.
         It is not part of React itself, but is commonly used with React to describe the UI structure.
         JSX is not Html inside JS. It is a syntax extension that looks similar to HTML.


21. How jsx is converted to js? 
    (e.g. <h1 id="heading">Hello World from jsx</h1>)
=> Behind the scenes, JSX is transformed into regular JavaScript function calls that create React elements.
   The transformation is typically done using a tool like Babel, which is a popular JavaScript transpiler.
   Parcel uses babel to convert jsx to React.createElement.

   JSX ==> React.createElement -JS Object ==> HTMLElement(render)   - Here Babel is converting jsx to React.createElement


23. What is transpiler?
=> A transpiler (short for "source-to-source compiler") is a type of compiler that takes source code 
   written in one programming language and transforms it into equivalent source code in another programming 
   language.
   Transpilers are commonly used to convert code from a newer version of a language to an older version, 
   or to convert code from one language to another that has similar features.



24. ***We have to use camelCase for attributes in jsx instead of lowercase.
     e.g. - class --> className
           tabindex --> tabIndex
           onclick --> onClick
           for --> htmlFor


25. ***If we write jsx in multiple lines, we have to wrap it in brackets.


26. What are components in react?
=> Components are the building blocks of a React application. They are reusable, self-contained pieces of
   code that define how a certain part of the user interface (UI) should look and behave.
   Components can be thought of as custom HTML elements that encapsulate their own structure, 
   styling, and behavior.

   i> Functional Components: These are JavaScript functions that return JSX to define the UI.
                           (A Arrow function that returns a React element) - [We can write normal function also]
                           Example:
                           const MyComponent = () => {
                             return <div>Hello, I am a functional component!</div>;
                           };

                           or if the function has only one return statement, we can write it like this:
                           const MyComponent = () => <div>Hello, I am a functional component!</div>;

                     ***How to render a functional component to the UI?
                       ==> const HeadingComponent = () => <h1>This is a Heading Component</h1>;
                           const root = ReactDOM.createRoot(document.getElementById("root"));
                           root.render(<HeadingComponent/>);  //we have to use the component as a tag


  ii> Class Based Components (older way, less used now)



27. What is component composition?
=> Component composition is a design pattern in React that allows you to build complex UIs by combining
   simpler, reusable components. It involves nesting components within other components to create a hierarchy
   of UI elements.

   Example:
   const Header = () => <header><h1>My Website</h1></header>;
   const Footer = () => <footer><p>© 2023 My Website</p></footer>;
   const MainContent = () => <main><p>Welcome to my website!</p></main>;

   const App = () => (
     <div>
       <Header />
       <MainContent />
       <Footer />
     </div>
   );

   In this example, the App component is composed of three smaller components: Header, MainContent, and Footer.
   Each of these components is responsible for rendering a specific part of the UI, and they are combined
   together in the App component to create the overall structure of the application.


28. Give example where we can inject React element in React element?
=> const elem = <span>Namaste React</span>;
   const title = (
      <h1> {elem} using JSX</h1>
   )

   const HeadingComponent = () => (
      <div id="container">
         {title}
      </div>
   )



29. What is the difference between React Element and React Component?
=> React Element: A React element is a plain JavaScript object that represents a DOM node or a component instance.
                  It is the smallest building block of a React application and describes what you want to see on the screen.
                  React elements are created using JSX or the React.createElement() method.

   React Component: A React component is a reusable piece of code that defines how a certain part of the user interface (UI) should look and behave.
                    Components can be thought of as custom HTML elements that encapsulate their own structure, styling, and behavior.
                    Components can be functional components (JavaScript functions that return JSX) or class-based components (ES6 classes that extend React.Component).

   In summary, a React element is an object that represents a DOM node or component instance, while a React component is a reusable 
   piece of code that defines the structure and behavior of a part of the UI.


30. What is Cross Site Scripting (XSS) attack? How jsx prevents it?
=> Cross-Site Scripting (XSS) is a type of security vulnerability that allows attackers to inject malicious 
scripts into web pages viewed by other users.
   JSX prevents XSS attacks by escaping any values embedded in JSX before rendering them to the DOM.
   This means that any potentially dangerous characters (like <, >, &, etc.) are converted to their 
   corresponding HTML entities (like &lt;, &gt;, &amp;, etc.), which prevents them from being interpreted 
   as executable code by the browser.



31. Describe where to use which one? - {Title()} vs <Title /> vs <Title></Title>
=> {Title()} - This syntax is used to call a regular JavaScript function named Title and embed its return value
                directly into JSX. This is typically used when Title is a function that returns a React element or
                some other value that you want to render.

   <Title /> - This syntax is used to render a React component named Title. It is a self-closing tag, which means
                that it does not have any children. This is typically used when Title is a functional or class-based
                component that you want to include in your JSX.

   <Title></Title> - This syntax is also used to render a React component named Title, but it allows you to include
                     children between the opening and closing tags. This is useful when Title is a component that
                     expects to receive child elements as props.

   In summary, use {Title()} to call a regular function and embed its return value, use <Title /> to render a 
   self-contained React component, and use <Title></Title> to render a React component that can accept child elements.


32. how to write inline css in react jsx?
=> In React JSX, we can write inline CSS styles using the style attribute, 
   but instead of a string (like in plain HTML), we pass a JavaScript object.

   Example:
      function App() {
         const boxStyle = {
         backgroundColor: "lightgreen",
   };

      return (
         <div style={boxStyle}>
            <p style={{ fontWeight: "bold" }}>This is styled with inline CSS!</p>
         </div>
      );
   }


33. What is Props?
=> ***Passing a prop to a function is like passing an argument to a function.

   Props (short for "properties") are a way to pass data from a parent component to a child component in React.
   They are read-only and allow components to be dynamic and reusable by accepting different values.

   Example:
   const Greeting = (props) => {
     return (
      <div>
      console.log(props); //props is an object
        <h1>Hello, {props.name}!</h1>;
      </div>
     )
   };

   const App = () => {
     return (
       <div>
         <Greeting name="Alice" /> //Here we are passing name="Alice" as props to Greeting component
         <Greeting name="Bob" />
       </div>
     );
   };

   In this example, the Greeting component accepts a prop called name and uses it to display a personalized greeting.
   The App component renders two instances of the Greeting component with different name props, resulting in
   "Hello, Alice!" and "Hello, Bob!" being displayed.



34. What is destructuring props on the fly?
=> Destructuring props on the fly refers to the practice of extracting specific properties from the props object
   directly within the function parameter list of a functional component in React.
   This allows for cleaner and more concise code by avoiding repetitive references to props.

   Example without destructuring:
   const Greeting = (props) => {
     return <h1>Hello, {props.name}!</h1>;
   };

   Example with destructuring on the fly:
   const Greeting = ({ name }) => {
     return <h1>Hello, {name}!</h1>;
   };

   In this example, instead of accessing the name property via props.name, we destructure it directly in the
   function parameter list by using { name }. This makes the code more readable and reduces redundancy.
   This is not React specific, it is a feature of JavaScript ES6.

   Basically this is same as:
   const Greeting = (props) => {
     const { name } = props; //destructuring
     return <h1>Hello, {name}!</h1>;
   };



35. What is Config Driven UI?
=> Config Driven UI is a design approach where the user interface (UI) of an application is
   dynamically generated based on configuration data rather than being hardcoded in the application's source code.
   This allows for greater flexibility and adaptability, as changes to the UI can be made by simply updating
   the configuration data without needing to modify the underlying code.

   Example:
   const restaurantList = [
     {
       name: "Meghana Foods",
       cuisine: ["Biryani", "North Indian", "Asian"],
       rating: "4.5",
     },
     {
       name: "KFC",
       cuisine: ["Burger", "Fast Food"],
       rating: "4.2",
     },
   ];

   const RestaurantCard = ({ resName, resCuisine }) => {
     return (
       <div className="res-card">
         <h3>{resName}</h3>
         <h4>{resCuisine}</h4>
       </div>
     );
   };

   const App = () => {
     return (
       <div className="body">
         <div className="search">Search</div>
         <div className="res-container">
           {restaurantList.map((restaurant) => (
             <RestaurantCard
               resName={restaurant.name}
               resCuisine={restaurant.cuisine.join(", ")}
             />
           ))}
         </div>
       </div>
     );
   };

   In this example, the restaurantList array serves as the configuration data that drives the UI.
   The App component maps over this array to dynamically generate RestaurantCard components for each restaurant,
   passing the relevant data as props. This way, if we want to add or remove restaurants, we can simply update
   the restaurantList array without changing the App or RestaurantCard components.
